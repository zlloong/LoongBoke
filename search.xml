<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML</title>
    <url>/HTML-CSS/20191224-HTML.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>HTML5 CSS3 常用规范</p><a id="more"></a><!-- rebuild by neat -->]]></content>
      <categories>
        <category>HTML,CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据可视化</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20191223-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>python 所用的作图包<br>from pyecharts import Bar<br>import pyecharts<br>from pyecharts import Bar3D#3D 构图<br>特点:<br>柱状图比较,折线图趋势,饼状图比例,散点图 做二维数组的比较<br>雷达图做思维以上的数据对比</p><a id="more"></a><h3 id="柱形图"><a href="#柱形图" class="headerlink" title="柱形图"></a>柱形图</h3><blockquote><p>attr=[“奥迪”,”宝马”,”大众”]#定义值<br>v1 = [10000,2332,2332]#参数<br>bar=Bar(“汽车品牌销售”)#标题<br>bar.add(“韩城”,attr,v2,is_stack=True) 可以叠加添加条柱形图,参数mkar_point=[“average”]平均值,,mkrk_point=[“min”,”max”])#俩个块之间的距离<br>可用函数 sum等</p></blockquote><h3 id="3d画图"><a href="#3d画图" class="headerlink" title="3d画图"></a>3d画图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar3d &#x3D; Bar3D(&quot;3D 柱状图示例&quot;, width&#x3D;1200, height&#x3D;600)</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加坐标</span></pre></td></tr><tr><td class="code"><pre><span class="line">x_axis &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;12a&quot;, &quot;1a&quot;, &quot;2a&quot;, &quot;3a&quot;, &quot;4a&quot;, &quot;5a&quot;, &quot;6a&quot;, &quot;7a&quot;, &quot;8a&quot;, &quot;9a&quot;, &quot;10a&quot;, &quot;11a&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;12p&quot;, &quot;1p&quot;, &quot;2p&quot;, &quot;3p&quot;, &quot;4p&quot;, &quot;5p&quot;, &quot;6p&quot;, &quot;7p&quot;, &quot;8p&quot;, &quot;9p&quot;, &quot;10p&quot;, &quot;11p&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">坐标</span></pre></td></tr><tr><td class="code"><pre><span class="line">y_axis &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;Saturday&quot;, &quot;Friday&quot;, &quot;Thursday&quot;, &quot;Wednesday&quot;, &quot;Tuesday&quot;, &quot;Monday&quot;, &quot;Sunday&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">data &#x3D; [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [0, 0, 5], [0, 1, 1], [0, 2, 0], [0, 3, 0], [0, 4, 0], [0, 5, 0],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [0, 6, 0], [0, 7, 0], [0, 8, 0], [0, 9, 0], [0, 10, 0], [0, 11, 2],</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="code"><pre><span class="line">添加构图的颜色</span></pre></td></tr><tr><td class="code"><pre><span class="line">range_color &#x3D; [&#39;#313695&#39;, &#39;#4575b4&#39;, &#39;#74add1&#39;, &#39;#abd9e9&#39;, &#39;#e0f3f8&#39;, &#39;#ffffbf&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#39;#fee090&#39;, &#39;#fdae61&#39;, &#39;#f46d43&#39;, &#39;#d73027&#39;, &#39;#a50026&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">bar3d.add(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_axis,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_axis,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [[d[1], d[0], d[2]] for d in data],#遍历数据中的元素然后传递给d</span></pre></td></tr><tr><td class="code"><pre><span class="line">    is_visualmap&#x3D;True,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visual_range&#x3D;[0, 20],</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visual_range_color&#x3D;range_color,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grid3d_width&#x3D;200,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grid3d_depth&#x3D;80,</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure><h3 id="动态散点图"><a href="#动态散点图" class="headerlink" title="动态散点图"></a>动态散点图</h3><p>可用生成动态网页来观看<br>参数可用列表<br>es=pyecharts.EffectScatter(“动态散点图”)<br>es.add(“销售额度”,v1,v2)<br>es.render()#下载成一个网页图片</p><h3 id="漏斗图"><a href="#漏斗图" class="headerlink" title="漏斗图"></a>漏斗图</h3><blockquote><p>fu=pyecharts.Funnel(“漏斗图”)<br>attr=[“袜子”,”羊毛衫”,”牛仔裤”,”高跟鞋”,”b背包”]<br>fu.add(“商品价格”,attr,v2,is_label_show=True,funnel_sort=”ascending”)#是否显示标签 funnel_sort 翻转排序</p></blockquote><h3 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h3><p>gauge=pyecharts.Gauge(“仪表盘”)<br>gauge.add(“业务指标”,”完成率”,random.randint(4,100))#仪表盘</p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>#饼图<br>attr=[“袜子”,”羊毛衫”,”牛仔裤”]<br>v1=[10,20,70]<br>pie=pyecharts.Pie(“饼图”)<br>pie.add(“占额”,attr,v1,radiu=[20,75],rosetype=”area”)#rosetype 风格</p><h3 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radar&#x3D;pyecharts.Radar()</span></pre></td></tr><tr><td class="code"><pre><span class="line">schema &#x3D; [ </span></pre></td></tr><tr><td class="code"><pre><span class="line">    (&quot;销售&quot;, 6500), (&quot;管理&quot;, 16000), (&quot;信息技术&quot;, 30000),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (&quot;客服&quot;, 38000), (&quot;研发&quot;, 52000), (&quot;市场&quot;, 25000)</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="code"><pre><span class="line">v1 &#x3D; [[4300, 10000, 28000, 35000, 50000, 19000]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">v2 &#x3D; [[5000, 14000, 28000, 31000, 42000, 21000]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">radar.config(schema)</span></pre></td></tr><tr><td class="code"><pre><span class="line">radar.add(&quot;预算&quot;,v1,)</span></pre></td></tr><tr><td class="code"><pre><span class="line">radar.add(&quot;预算&quot;,v2,)</span></pre></td></tr></table></figure><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nodes&#x3D;[</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;&quot;name&quot;:&quot;马云&quot;,&quot;money&quot;:&quot;200000&quot;,&quot;symbolSize&quot;:40&#125;,]</span></pre></td></tr><tr><td class="code"><pre><span class="line">link&#x3D;[]</span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in nodes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for j in nodes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        link.append(&#123;&quot;source&quot;:i.get(&quot;name&quot;),&quot;target&quot;:j.get(&quot;name&quot;)&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">graph&#x3D;pyecharts.Graph(&quot;关系图&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">graph.add(&quot;&quot;,nodes,link,repulsion&#x3D;600)</span></pre></td></tr></table></figure><h3 id="重点图-字体大小"><a href="#重点图-字体大小" class="headerlink" title="重点图 字体大小"></a>重点图 字体大小</h3><blockquote><p>name=[“垃圾”,”清洁干净”,”妈妈喜欢”,”赞”,”真好”,”泡沫多”]<br>alue=[100,20,10,33,6,30]#数据对应上面一个<br>word=pyecharts.WordCloud(width=1200,height=600)<br>word.add(“”,name,value,word_size_range=[20,90])</p></blockquote><h3 id="利用json数据转化饼图"><a href="#利用json数据转化饼图" class="headerlink" title="利用json数据转化饼图"></a>利用json数据转化饼图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f&#x3D;open(&quot;pies.json&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">data&#x3D;json.load(f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">name &#x3D;data[&#39;name&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">value&#x3D;data[&quot;sales&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">pie&#x3D;pyecharts.Pie(&quot;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">pie.add(&quot;&quot;,name,value)</span></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析4</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20191223-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%904.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>数据获取挖掘分析<br>词频 获取分析某些数据词语出现的频率<br>import jieba 用来划分词语的包</p><a id="more"></a><h3 id="首先设置出现最多的句子"><a href="#首先设置出现最多的句子" class="headerlink" title="首先设置出现最多的句子"></a>首先设置出现最多的句子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D;pd.read_csv(&quot;zhihu.csv&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">text_all&#x3D;[]</span></pre></td></tr><tr><td class="code"><pre><span class="line">counts&#x3D;&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in df[&#39;评论内容&#39;]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    text_all.append(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for word in text_all:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    counts[word]&#x3D;counts.get(word,0)+1</span></pre></td></tr><tr><td class="code"><pre><span class="line">items&#x3D;list(counts.items())</span></pre></td></tr><tr><td class="code"><pre><span class="line">items.sort(key&#x3D; lambda x:x[1],reverse&#x3D;True)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in range(4):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    word,count&#x3D;items[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))</span></pre></td></tr></table></figure><h3 id="划分词语"><a href="#划分词语" class="headerlink" title="划分词语"></a>划分词语</h3><p>jieba 分为 精确模式 搜索引擎模式 支持繁体 支持词典</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; open(&quot;zhihu.csv&quot;,&quot;r&quot;,encoding&#x3D;&quot;utf-8&quot;).read()</span></pre></td></tr><tr><td class="code"><pre><span class="line">words&#x3D;jieba.lcut(df)#</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(word)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for word in word:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if len(word) &#x3D;&#x3D;1:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        continue</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        counts[word]&#x3D;counts.get(word,0)+1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">items&#x3D;list(counts.items())</span></pre></td></tr><tr><td class="code"><pre><span class="line">items.sort(key&#x3D; lambda x:x[1],reverse&#x3D;True)</span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in range(41):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    word,count&#x3D;items[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(&quot;&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;&quot;.format(word,count))</span></pre></td></tr></table></figure><blockquote><p>jieba.lut #返回列表<br>cut_all 不使用全模式 默认不适用全模式<br>HMM 是一个模型 默认为True<br>all_list=jieba.cut(text,cut_all=True)#全模式把字全部都分出<br>all_list=jieba.cut(text,cut_all=False)#精确模式将词语划分 长词语适合用搜索模式<br>all_list=jieba.cut_for_search(text)#搜索模式#搜索引擎模式 是对长词语的划分 任何情况下不会改变语句的顺序<br>print(“,”.join(all_list))#打印</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器使用</title>
    <url>/%E5%B7%A5%E5%85%B7/20191220-docker.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>Docker有Docker-CE和Docker-EE两种。<br>Docker-CE指Docker社区版，由社区维护和提供技术支持，为免费版本，适合个人开发人员和小团队使用。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装必要的一些系统工具<br>sudo apt-get update<br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br>安装GPG证书<br>curl -fsSL <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -<br>写入软件源信息<br>sudo add-apt-repository “deb [arch=amd64] <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu</a> $(lsb_release -cs) stable”<br>更新并安装Docker-CE<br>sudo apt-get -y update<br>sudo apt-get -y install docker-ce<br>docker version 检测</p><h3 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h3><p>Docker的镜像概念类似于咱们使用的虚拟机的镜像，是一个独立的文件系统。<br>注：Docker是只读的<br>容器和虚拟机一样，都会对物理硬件资源进行共享使用。<br>容器和虚拟机的生命周期比较相似（创建、运行、暂停、关闭等等）。<br>容器中或虚拟机中都可以安装各种应用，如redis、mysql、nginx等。也就是说，在容器中的操作，如同在一个虚拟机(操作系统)中操作一样。<br>同虚拟机一样，容器创建后，会存储在宿主机上：linux上位于/var/lib/docker/containers下</p><h3 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a>容器创建</h3><blockquote><p>docker create [参数] 镜像名称[容器执行命令][执行命令时需要提供的参数]<br>-t: 分配一个虚拟终端<br>-i :提供一个模拟输入，不提供则无法输入默认命令<br>–name :为创建好的容器提供一个容器名，不提供的话随机分配一个</p></blockquote><p>启动</p><blockquote><p>docker start [参数] 容器[容器..]<br>-a :将当前的输入/输出连接到容器<br>-i :将当前的输入连接到容器上</p></blockquote><h3 id="容器和镜像的关系"><a href="#容器和镜像的关系" class="headerlink" title="容器和镜像的关系"></a>容器和镜像的关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式:  提交容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker commit [参数] 容器[版本]</span></pre></td></tr><tr><td class="code"><pre><span class="line">-a 添加作者</span></pre></td></tr><tr><td class="code"><pre><span class="line">-c 为创建的镜像加入Dockerfile命令</span></pre></td></tr><tr><td class="code"><pre><span class="line">-m 类似git commit -m</span></pre></td></tr><tr><td class="code"><pre><span class="line">-p 提交时暂停容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">命令格式:导出命令</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker export [参数] 容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">-o 指定写入的文件</span></pre></td></tr></table></figure><p>将之前导出的容器文件导入并创建为镜像<br>命令格式:<br>docker import [参数] 文件|链接|[版本信息]<br>-m 导入时添加提交信息<br>-c 应用docker 指令创建镜像；</p><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>Docker仓库就是存放docker镜像并有docker pull方法下载的云环境<br>公有仓库指Docker Hub(官方)等开放给用户使用、允许用户管理镜像。<br>私有仓库指由用户自行搭建的存放镜像的云环境。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>python关键字</title>
    <url>/uncategorized/20191219-python%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>迭代器 生成器 lamblad</p><a id="more"></a><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>可迭代对象(iterable)<br>可以通过for…in…这类语句迭代读取⼀条数据供我们使用的对象称之可迭代对象</p><p>迭代器(iterator)<br>可以记住遍历的位置的对象。只能前进，不能后退</p><p>生成器<br>生成器调用 next() 时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。 显示如何非常容易地创建生成器的示例如下:</p><p>lambda 参数,参数…：函数功能代码<br>如：lambda x,y:x + y 获取2个值的和的lambda函数</p><p>global关键字</p><h3 id="列表推到是"><a href="#列表推到是" class="headerlink" title="列表推到是"></a>列表推到是</h3><blockquote><p>格式：[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 if 条件表达式]<br>变量 = {i+x:j+y for i，j in 字典1.items for x，y in 字典2.items() if 条件表达式}字典推到</p></blockquote><h3 id="深浅复制"><a href="#深浅复制" class="headerlink" title="深浅复制"></a>深浅复制</h3><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>数据分析3</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20191219-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%903.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>机器学习<br>监督学习 半监督学习 无监督学习 迁移学习 结构化学习<br>如果预测目标变量只能取一小部分离散值分类问题<br>无监督 是没有标记的学习<br>聚类 降维<br>在已经学习的基础上预测其他的东西<br>statsmodels<br>执行多种统计模型数据探索和可视化;<br>线性模型<br>残差的自由度 模型的个数</p><a id="more"></a><h3 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h3><blockquote><p>data = pd.DataFrame(np.random.randn(1000,4))# 设置随机数据<br>data.describe() #查看表数据<br>data[2][np.abs(data[2])&gt;3]# 找出列绝对值大于三的值<br>data[(np.abs(data)&gt;3).any(1)]<br>data[np.abs(data)&gt;3] = np.sign(data)*3#大于3小于-3 改为3 -3</p></blockquote><h3 id="正则查看表数据"><a href="#正则查看表数据" class="headerlink" title="正则查看表数据"></a>正则查看表数据</h3><blockquote><p>df.link.str.extract(“(\d+)”)#查找字段为数字的<br>df.link.str.extract(“(?P<url>.*)/(?P<id>\d+)”)#修改字段名称为url 和ID</id></url></p></blockquote><h4 id="将表数据写入新表"><a href="#将表数据写入新表" class="headerlink" title="将表数据写入新表"></a>将表数据写入新表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db&#x3D;pd.DataFrame()</span></pre></td></tr><tr><td class="code"><pre><span class="line">db[&quot;等级&quot;]&#x3D;df.酒店信息.str.extract(&quot;\n(.*)&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">db[&quot;评分&quot;]&#x3D;df.酒店信息.str.extract(&quot;(\d+)分&quot;).apply(lambda x :int(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">db[&quot;天数&quot;]&#x3D;df.路线信息.str.extract(&quot;(\d+)天\d+晚&quot;).apply(lambda x :int(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">db[&quot;价格&quot;]&#x3D;df.路线信息.str.extract(&quot;(\d+)起&#x2F;人&quot;).apply(lambda x :int(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">db.to_csv(&quot;.&#x2F;2019-1219.csv&quot;,encoding&#x3D;&quot;utf-8_sig&quot;,index&#x3D;False)</span></pre></td></tr></table></figure><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&quot;2019-12-19(1).csv&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">class_map&#x3D;&#123;&quot;其他&quot;:0,&quot;经济型&quot;:1,&quot;舒适型&quot;:2,&quot;高档型&quot;:3,&quot;豪华型&quot;:4&#125;# 写图标</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&quot;等级&quot;]&#x3D;df[&quot;等级&quot;].map(class_map)</span></pre></td></tr><tr><td class="code"><pre><span class="line">fig,ax&#x3D;plt.subplots(1,3,figsize&#x3D;(12,4))#设置三个表格</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&quot;等级&quot;].plot(ax&#x3D;ax[2],kind&#x3D;&quot;hist&quot;,title&#x3D;&quot;等级&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&quot;评分&quot;].plot(ax&#x3D;ax[0],kind&#x3D;&quot;hist&quot;,title&#x3D;&quot;酒店评分&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&quot;价格&quot;].plot(ax&#x3D;ax[1],kind&#x3D;&quot;hist&quot;,title&#x3D;&quot;价格&quot;) #因变量</span></pre></td></tr><tr><td class="code"><pre><span class="line">#自，因变量</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;X&#x3D;df.iloc[:,:-1].values</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;Y&#x3D;df.iloc[:,-1].values</span></pre></td></tr><tr><td class="code"><pre><span class="line">#建立模型</span></pre></td></tr><tr><td class="code"><pre><span class="line">ols&#x3D;sm.OLS(Y,X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">result&#x3D;ols.fit()</span></pre></td></tr><tr><td class="code"><pre><span class="line">result.summary()</span></pre></td></tr><tr><td class="code"><pre><span class="line">#预测路线价格</span></pre></td></tr><tr><td class="code"><pre><span class="line">y&#x3D;result.predict(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">#测试俩者的比值</span></pre></td></tr><tr><td class="code"><pre><span class="line">retio&#x3D;y&#x2F;Y</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&quot;预估价&quot;]&#x3D;y</span></pre></td></tr><tr><td class="code"><pre><span class="line">df[&#39;性价比&#39;]&#x3D;retio</span></pre></td></tr><tr><td class="code"><pre><span class="line">df&#x3D;df1.join(df)</span></pre></td></tr><tr><td class="code"><pre><span class="line">df2&#x3D;df[(df[&quot;性价比&quot;]&gt;1.50) &amp; (df[&quot;天数&quot;]&gt;8)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">df2.sort_values(&quot;性价比&quot;,ascending&#x3D;False)</span></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20191219-%E5%8D%95%E9%93%BE%E8%A1%A8.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>基于Python实现数据结构单链表操作</p><a id="more"></a><h3 id="定义单链表"><a href="#定义单链表" class="headerlink" title="定义单链表"></a>定义单链表</h3><p>@property 魔术方法 相当于Java getset对属性进行验证会生成 @data.setter来设置方法<br>链表结构的Node节点<br>data:存储的数据<br>next:下一个Node节点的引用地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node(object):</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def __int__(self,data,next_node&#x3D;None):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__data &#x3D; data</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__next &#x3D; next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @property</span></pre></td></tr><tr><td class="code"><pre><span class="line">    def data(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return self.__data</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @data.setter</span></pre></td></tr><tr><td class="code"><pre><span class="line">    def data(self,data):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__data &#x3D; data</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @property</span></pre></td></tr><tr><td class="code"><pre><span class="line">    def next_node(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return self.__next</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @next_node.setter</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&quot;&quot;&quot;Node节点next指针的修改方法.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            next:新的下一个Node节点的引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    def next_node(self,next_node):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__next &#x3D; next_node#链表一直来链接节点 所有一直指向下一个</span></pre></td></tr></table></figure><h3 id="链表的正删改查"><a href="#链表的正删改查" class="headerlink" title="链表的正删改查"></a>链表的正删改查</h3><p>链表初始化首先使将头节点设置为None</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SinglyLinkedList(object):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&quot;&quot;单向链表&quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def __init__(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;单向列表的初始化方法.&quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__head &#x3D; None</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def find_by_value(self, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;按照数据值在单向列表中查找.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value:查找的数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">        返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while (node is not None) and (node.data !&#x3D; value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def find_by_index(self, index):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;按照索引值在列表中查找.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            index:索引值</span></pre></td></tr><tr><td class="code"><pre><span class="line">        返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while (node is not None) and (pos !&#x3D; index):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pos +&#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def insert_to_head(self, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;在链表的头部插入一个存储value数值的Node节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value:将要存储的数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node &#x3D; Node(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node.next_node &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__head &#x3D; node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def insert_after(self, node, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;在链表的某个指定Node节点之后插入一个存储value数据的Node节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node:指定的一个Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value:将要存储在新Node节点中的数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if node is None:  # 如果指定在一个空节点之后插入数据节点，则什么都不做</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_node &#x3D; Node(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_node.next_node &#x3D; node.next</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node.next &#x3D; new_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def insert_before(self, node, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;在链表的某个指定Node节点之前插入一个存储value数据的Node节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node:指定的一个Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value:将要存储在新的Node节点中的数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (node is None) or (self.__head is None):  # 如果指定在一个空节点之前或者空链表之前插入数据节点，则什么都不做</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        if node &#x3D;&#x3D; self.__head:  # 如果是在链表头之前插入数据节点，则直接插入</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.insert_to_head(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_node &#x3D; Node(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pro &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        not_found &#x3D; False  # 如果在整个链表中都没有找到指定插入的Node节点，则该标记量设置为True</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while pro.next_node !&#x3D; node:  # 寻找指定Node之前的一个Node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if pro.next_node is None:  # 如果已经到了链表的最后一个节点，则表明该链表中没有找到指定插入的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">                not_found &#x3D; True</span></pre></td></tr><tr><td class="code"><pre><span class="line">                break</span></pre></td></tr><tr><td class="code"><pre><span class="line">            else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pro &#x3D; pro.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if not not_found:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pro.next_node &#x3D; new_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            new_node.next_node &#x3D; node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def delete_by_node(self, node):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;在链表中删除指定Node的节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node:指定的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if self.__head is None:  # 如果链表是空的，则什么都不做</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        if node &#x3D;&#x3D; self.__head:  # 如果指定删除的Node节点是链表的头节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__head &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pro &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        not_found &#x3D; False  # 如果在整个链表中都没有找到指定删除的Node节点，则该标记量设置为True</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while pro.next_node !&#x3D; node:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if pro.next_node is None:  # 如果已经到链表的最后一个节点，则表明该链表中没有找到指定删除的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">                not_found &#x3D; True</span></pre></td></tr><tr><td class="code"><pre><span class="line">                break</span></pre></td></tr><tr><td class="code"><pre><span class="line">            else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pro &#x3D; pro.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if not not_found:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pro.next_node &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def delete_by_value(self, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;在链表中删除指定存储数据的Node节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            value:指定的存储数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if self.__head is None:  # 如果链表是空的，则什么都不做</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        if self.__head.data &#x3D;&#x3D; value:  # 如果链表的头Node节点就是指定删除的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__head &#x3D; self.__head.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pro &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node &#x3D; self.__head.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        not_found &#x3D; False</span></pre></td></tr><tr><td class="code"><pre><span class="line">        while node.data !&#x3D; value:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if node.next_node is None:  # 如果已经到链表的最后一个节点，则表明该链表中没有找到执行Value值的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">                not_found &#x3D; True</span></pre></td></tr><tr><td class="code"><pre><span class="line">                break</span></pre></td></tr><tr><td class="code"><pre><span class="line">            else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pro &#x3D; node</span></pre></td></tr><tr><td class="code"><pre><span class="line">                node &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if not_found is False:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pro.next_node &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def delete_last_n_node(self, n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;删除链表中倒数第N个节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        主体思路：</span></pre></td></tr><tr><td class="code"><pre><span class="line">            设置快、慢两个指针，快指针先行，慢指针不动；当快指针跨了N步以后，快、慢指针同时往链表尾部移动，</span></pre></td></tr><tr><td class="code"><pre><span class="line">            当快指针到达链表尾部的时候，慢指针所指向的就是链表的倒数第N个节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">        参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            n:需要删除的倒数第N个序数</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fast &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        slow &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        step &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        while step &lt;&#x3D; n:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast &#x3D; fast.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            step +&#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        while fast.next_node is not None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp &#x3D; slow</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast &#x3D; fast.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            slow &#x3D; slow.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tmp.next_node &#x3D; slow.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    def find_mid_node(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;查找链表中的中间节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">        主体思想:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            设置快、慢两种指针，快指针每次跨两步，慢指针每次跨一步，则当快指针到达链表尾部的时候，慢指针指向链表的中间节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">        返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node:链表的中间节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fast &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">        slow &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        while fast.next_node is not None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast &#x3D; fast.next_node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">            slow &#x3D; slow.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        return slow</span></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create_node(self, value):</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;创建一个存储value值的Node节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value:将要存储在Node节点中的数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">      返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          一个新的Node节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      return Node(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  def print_all(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;打印当前链表所有节点数据.&quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pos &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">      if pos is None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          print(&quot;当前链表还没有数据&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          return</span></pre></td></tr><tr><td class="code"><pre><span class="line">      while pos.next_node is not None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          print(str(pos.data) + &quot; --&gt; &quot;, end&#x3D;&quot;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pos &#x3D; pos.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">      print(str(pos.data))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  def reversed_self(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;翻转链表自身.&quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      if self.__head is None or self.__head.next is None:  # 如果链表为空，或者链表只有一个节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">          return</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      pre &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">      node &#x3D; self.__head.next</span></pre></td></tr><tr><td class="code"><pre><span class="line">      while node is not None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pre, node &#x3D; self.__reversed_with_two_node(pre, node)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      self.__head.next &#x3D; None</span></pre></td></tr><tr><td class="code"><pre><span class="line">      self.__head &#x3D; pre</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  def __reversed_with_two_node(self, pre, node):</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;翻转相邻两个节点.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      参数:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          pre:前一个节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">          node:当前节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">      返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          (pre,node):下一个相邻节点的元组</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      tmp &#x3D; node.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">      node.next_node &#x3D; pre</span></pre></td></tr><tr><td class="code"><pre><span class="line">      pre &#x3D; node  # 这样写有点啰嗦，但是能让人更能看明白</span></pre></td></tr><tr><td class="code"><pre><span class="line">      node &#x3D; tmp</span></pre></td></tr><tr><td class="code"><pre><span class="line">      return pre, node</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  def has_ring(self):</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;检查链表中是否有环.</span></pre></td></tr><tr><td class="code"><pre><span class="line">      主体思想：</span></pre></td></tr><tr><td class="code"><pre><span class="line">          设置快、慢两种指针，快指针每次跨两步，慢指针每次跨一步，如果快指针没有与慢指针相遇而是顺利到达链表尾部</span></pre></td></tr><tr><td class="code"><pre><span class="line">          说明没有环；否则，存在环</span></pre></td></tr><tr><td class="code"><pre><span class="line">      返回:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          True:有环</span></pre></td></tr><tr><td class="code"><pre><span class="line">          False:没有环</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &quot;&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fast &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line">      slow &#x3D; self.__head</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      while (fast.next_node is not None) and (fast is not None):</span></pre></td></tr><tr><td class="code"><pre><span class="line">          fast &#x3D; fast.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">          slow &#x3D; slow.next_node</span></pre></td></tr><tr><td class="code"><pre><span class="line">          if fast &#x3D;&#x3D; slow:</span></pre></td></tr><tr><td class="code"><pre><span class="line">              return True</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      return False</span></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ip地址池</title>
    <url>/%E7%88%AC%E8%99%AB/20191217-ip%E5%9C%B0%E5%9D%80%E6%B1%A0.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>爬虫过程中遇到反爬需要很多的ip地址网上有许多的免费的代理<br>但是能用不多所以利用爬虫爬去验证存入数据库的ip</p><a id="more"></a><h3 id="ip校验"><a href="#ip校验" class="headerlink" title="ip校验"></a>ip校验</h3><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫提取</title>
    <url>/%E7%88%AC%E8%99%AB/20191217-null.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>爬虫提取经常用正则 xpath bs4 jsonpath</p><a id="more"></a><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p><a href="http://ermao7.coding.me/python/20191208-index.html">正则</a></p><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><blockquote><p>/ 从根节点选取。xpath(‘/div’)从根节点上选取div节点<br>// 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。xpath(‘//div’)从当前节点选取含有div节点的标签<br>. 选取当前节点。xpath(‘./div’)选取当前节点下的div标签<br>.. 选取当前节点的父节点。 xpath(‘../’)回到上一级节点<br>@ 选取属性。xpath(“//div[@id=’1001’]”)获取div标签中，含有ID属性且值为1001的标签</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(html.xpath(&#39;&#x2F;&#x2F;a[@title&#x3D;&quot;hjq&quot; and @name&#x3D;&quot;hhh&quot;]&#x2F;&#x2F;h6&#x2F;text()&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(html.xpath(&quot;&#x2F;&#x2F;a&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(html.xpath(&quot;&#x2F;descendant::a&quot;))#当前节点的所有后代元素  相对路径</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(html.xpath(&quot;descendant::a&#x2F;child::p&quot;))</span></pre></td></tr></table></figure><h3 id="bs4"><a href="#bs4" class="headerlink" title="bs4"></a>bs4</h3><p>from bs4 import BeautifulSoup<br>test=BeautifulSoup(a.text,”lxml”)<br>a=test.select(“body &gt; div.layui”)<br>根据标签获取</p><h3 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h3><p>list1 = json.loads(response.decode(‘utf-8’))<br>response_json = json.loads(response.read().decode(“utf-8”))<br>print(jsonpath.jsonpath(response_json,’$..[?(@.name==”济宁”)]’))</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$	根节点。查询的根节点对象，用于表示一个json数据，可以是数组或对象</span></pre></td></tr><tr><td class="code"><pre><span class="line">@	当前节点。过滤器断言（filter predicate）处理的当前节点对象，类似于java中的this字段</span></pre></td></tr><tr><td class="code"><pre><span class="line">*	通配符，可以表示一个名字或数字</span></pre></td></tr><tr><td class="code"><pre><span class="line">..	选择所有符合条件的节点。可以理解为递归搜索，Deep scan. Available anywhere a name is required.</span></pre></td></tr><tr><td class="code"><pre><span class="line">. &lt; name &gt;or [&lt; name &gt;]	表示一个子节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">[‘&lt; name&gt;’ (, ‘&lt; name &gt;’)]	表示一个或多个子节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">[&lt; number &gt; (, &lt; number &gt;)]	表示一个或多个数组下标</span></pre></td></tr><tr><td class="code"><pre><span class="line">[start:end]	数组片段，区间为[start,end),不包含end</span></pre></td></tr><tr><td class="code"><pre><span class="line">[?(&lt; expression &gt;)]	过滤器表达式，表达式结果必须是boolea</span></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>反反爬虫</title>
    <url>/%E7%88%AC%E8%99%AB/20191217-%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>先在网上的反爬虫的措施比较多<br>所以要在爬虫代码添加上请求头 cooike ip代理 js等</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 头生成</span></pre></td></tr><tr><td class="code"><pre><span class="line">from faker import Factory</span></pre></td></tr><tr><td class="code"><pre><span class="line">fa &#x3D; Factory.create(&quot;zh_CN&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">fa.user_agent()</span></pre></td></tr></table></figure><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie  session"></a>cookie session</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;Cookie：通过在 客户端 记录的信息确定用户的身份。 Session：通过在 服务器端 记录的信息确定用户的身份</span></pre></td></tr><tr><td class="code"><pre><span class="line">from urllib import request, parse</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cookie &#x3D; cookiejar.CookieJar()</span></pre></td></tr><tr><td class="code"><pre><span class="line"> #创建cookie生成的管理器</span></pre></td></tr><tr><td class="code"><pre><span class="line">cookie_handle &#x3D; request.HTTPCookieProcessor(cookie)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> #创建请求管理器</span></pre></td></tr><tr><td class="code"><pre><span class="line">opener &#x3D; request.build_opener(cookie_handle)</span></pre></td></tr><tr><td class="code"><pre><span class="line">data &#x3D; parse.urlencode(data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">req &#x3D; request.Request(url&#x3D;login_url, data&#x3D;bytes(data, encoding&#x3D;&quot;utf-8&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">response &#x3D; opener.open(req)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">#### session</span></pre></td></tr></table></figure><p>login_url = “<a href="http://www.renren.com/PLogin.do&quot;" target="_blank" rel="noopener">http://www.renren.com/PLogin.do&quot;</a><br>data = {<br>“email”: “17865205230”,<br>“password”: “qwer123456.”,<br>#”icode”: a<br>}<br>session=requests.session()<br>proxy={ “http”:”39.137.69.7:8080”,<br>“https”:”39.137.69.7:8080”}##<br>logging.captureWarnings(True)<br>res=session.get(“<a href="http://httpbin.org/get&quot;,headers=header,proxies=proxy" target="_blank" rel="noopener">http://httpbin.org/get&quot;,headers=header,proxies=proxy</a>)<br>print(res.text)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 图形验证</span></pre></td></tr></table></figure><p>import pytesseract<br>from PIL import Image<br>image = Image.open(r”C:\Program Files\feiq\Recv Files\timg.jpg”)<br>image=image.convert(“L”)<br>threshold=127<br>table=[]<br>for i in range(256):<br>if i &lt; threshold:<br>table.append(0)<br>else:<br>table.append(1)<br>image = image.point(table,”1”)<br>result = pytesseract.image_to_string(image)<br>print(result)</p><pre><code></code></pre><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫使用1</title>
    <url>/%E7%88%AC%E8%99%AB/20191217-%E7%88%AC%E8%99%AB1.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>爬虫基础<br>爬虫分为通用爬虫和聚焦爬虫 通用爬虫应用搜索<br>专注爬一个页面叫做聚焦爬虫 基础</p><a id="more"></a><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML页面的方法。 HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版，在HTTP下加 入SSL层。<br>SSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加 密，保障在Internet上数据传输的安全。<br>HTTP的端口号为80，<br>HTTPS的端口号为443<br>Cookie 和 Session：<br>Cookie：通过在 客户端 记录的信息确定用户的身份。 Session：通过在 服务器端 记录的信息确定用户的身份</p><h3 id="urllib的包含的模块"><a href="#urllib的包含的模块" class="headerlink" title="urllib的包含的模块"></a>urllib的包含的模块</h3><blockquote><p>urllib.request 可以用来发送request和获取request的结果<br>urllib.error 包含了urllib.request产生的异常<br>urllib.parse 用来解析和处理URL<br>urllib.robotparse 用来解析页面的robots.txt文件<br>同时它还带有处理 authenticaton （授权验证）， redirections （重定向)， cookies (浏览器Cookies）以及其它内容。<br>通过输出结果可以发现它是一个 HTTPResposne 类型的对象<br>request.urlopen()详解<br>urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)</p></blockquote><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><blockquote><p>第一个 url 参数是请求 URL，这个是必传参数，其他的都是可选参数。<br>第二个 data 参数如果要传必须传 bytes（字节流）类型的，如果是一个字典，可以先用 urllib.parse 模块里的 urlencode() 编码。<br>第三个 headers 参数是一个字典，这个就是 Request Headers 了，你可以在构造 Request 时通过 headers 参数直接构造，也可以通过调用 Request 实例的 dd_header() 方法来添加, Request Headers 最常用的用法就是通过修改 User-Agent 来伪装浏览器，默认的 User-Agent 是 Python-urllib，我们可以通过修改它来伪装&gt;浏览器。<br>第四个 origin_req_host 参数指的是请求方的 host 名称或者 IP 地址。<br>第五个unverifiable 参数指的是这个请求是否是无法验证的，默认是False。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个 HTML 文档中的图片，但&gt;&gt;是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。<br>第六个 method 参数是一个字符串，它用来指示请求使用的方法，比如GET，POST，PUT等等。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 访问方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">### requests</span></pre></td></tr><tr><td class="code"><pre><span class="line">requests.get(data&#x3D;formdata)</span></pre></td></tr><tr><td class="code"><pre><span class="line">requests.post(url&#x3D;base_url,data&#x3D;formdata)</span></pre></td></tr><tr><td class="code"><pre><span class="line">response.encoding &#x3D; response.apparent_encoding #编码格式</span></pre></td></tr><tr><td class="code"><pre><span class="line">### request</span></pre></td></tr></table></figure><p>req = request.Request(url=base, headers=header)搭建请求<br>req = request.urlopen(req)#发送请求<br>print(req.read().decode(“utf-8”))#的奥数据<br>qs={“kw”:content}<br>content = parse.urlencode(qs)<br>#下载函数<br>request.urlretrieve(url,”./插图.jpg”,Schedule)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 写入</span></pre></td></tr></table></figure><p>json数据<br>with open(“douban.json”,”a+”,encoding=”utf-8”) as f:<br>f.write(json.dumps(i,ensure_ascii=False)+”\n”)<br>写入图片<br>name = path.split(“/“)[-1]<br>with open(r”D:\图片\新建文件夹\gif\ “+name, ‘wb+’) as jpg:<br>jpg.write(requests.get(path,headers=headers).content)</p><pre><code># 后记</code></pre><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析2</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20191217-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%902.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据分析采用Python语言用anacodna集成的环境</p><a id="more"></a><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><p>以位置来分组<br>group = df[“成交量”].groupby(df[“位置”])<br>group.sum() 和</p><h3 id="数据分组多列分组"><a href="#数据分组多列分组" class="headerlink" title="数据分组多列分组"></a>数据分组多列分组</h3><p>grpup = df[“成交量”].groupby([df[“位置”],df[“卖家”]<br>group.mean()#均值<br>df.groupby([“位置”]).sum()#卖家不是数值 所以在结果中被排掉了sum()# 卖家不是数值 所以在结果中被排掉了</p><h3 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h3><p>m1 = df[70:90][[“卖家”,”销售额”]]</p><h3 id="数据合并-同数据库"><a href="#数据合并-同数据库" class="headerlink" title="数据合并 同数据库"></a>数据合并 同数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.merge(m1,m2)#相同的元素作为索引</span></pre></td></tr><tr><td class="code"><pre><span class="line">pd.merge(m1,m2,on &#x3D; &quot;卖家&quot;)#指定索引</span></pre></td></tr><tr><td class="code"><pre><span class="line">pd.merge(m1,m2,how&#x3D;&quot;inner&quot;)#内联</span></pre></td></tr><tr><td class="code"><pre><span class="line">pd.merge(m1,m2,how&#x3D;&quot;outer&quot;)#外联</span></pre></td></tr><tr><td class="code"><pre><span class="line">pd.merge(m1,m2,how&#x3D;&quot;left&quot;)#外联</span></pre></td></tr><tr><td class="code"><pre><span class="line">pd.merge(m1,m2,how&#x3D;&quot;right&quot;)#外联</span></pre></td></tr></table></figure><h4 id="索引合并索引合并"><a href="#索引合并索引合并" class="headerlink" title="索引合并索引合并"></a>索引合并索引合并</h4><p>df1 = df[:10][[“位置”,”卖家”]]<br>df2 = df[:10][[“价格”,”成交量”]]<br>pd.merge(df1,df2,left_index=True,right_index=True) = df1.join(df2)#等于上一个</p><h4 id="轴想链接"><a href="#轴想链接" class="headerlink" title="轴想链接"></a>轴想链接</h4><blockquote><p>s1=df[0:5][“宝贝”]<br>s2=df[5:10][“宝贝”]<br>s3=df[10:15][“宝贝”]<br>pd.concat([s1,s2,s3])<br>s1=df[0:5][[“宝贝”,”价格”]]<br>s2=df[0:5][[“位置”,”卖家”]]<br>pd.concat([s1,s2],axis=1)</p></blockquote><h3 id="数据变形"><a href="#数据变形" class="headerlink" title="数据变形"></a>数据变形</h3><p>data.stack()#行<br>d2.unstack()</p><h4 id="数据试图"><a href="#数据试图" class="headerlink" title="数据试图"></a>数据试图</h4><p>d1 = data.set_index(“日期”)<br>#数据试图</p><blockquote><p>d1 = pd.pivot_table(d1,values=[“最低气温”,”最高气温”],index=[‘天气’],columns = [‘风向’])<br>d1#要展示的数据源<br>value 查看数据<br>index 行<br>columns列<br>aggfunc<br>aggfunc 默认平均值</p></blockquote><h3 id="数据缺省值"><a href="#数据缺省值" class="headerlink" title="数据缺省值"></a>数据缺省值</h3><p>选择出发地为上海的</p><blockquote><p>df3=pd.pivot_table(df[df[“出发地”]==”上海”],values=[“价格”],index=[“出发地”],columns=[“目的地”])<br>#数据处理 有缺失值 重复值异常值</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; pd.read_csv(&quot;hz_weather.csv&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1 &#x3D; pd.pivot_table(data,values&#x3D;[&quot;最低气温&quot;,&quot;最高气温&quot;],index&#x3D;[&#39;天气&#39;],columns &#x3D; [&#39;风向&#39;])</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.isnull()#判断空</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.dropna()#清除包含空的所有数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.dropna(how&#x3D;&quot;all&quot;)#清除全为空</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.dropna(thresh&#x3D;12)#保留至少有n个非NaN数据的行</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.dropna(axis&#x3D;1)#删除行</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.dropna(axis&#x3D;0)#删除行</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.fillna(&quot;未找到&quot;)#将字符串替换.空</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.fillna(method&#x3D;&quot;pad&quot;)#pad ffill 上一个值拿来填充</span></pre></td></tr><tr><td class="code"><pre><span class="line">db1.fillna(method&#x3D;&quot;bfill&quot;,limit&#x3D;1)#bfill 用下一个值来填充 limit 限制填充个数</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 重复值</span></pre></td></tr><tr><td class="code"><pre><span class="line">data.duplicated(&quot;最高气温&quot;)#subset列 默认是用所有的列,keep&#x3D;&quot;first&quot;默认值为第一次出现重复值就标为true &quot;last&quot;最后一次出现重复项 False 将所有True</span></pre></td></tr><tr><td class="code"><pre><span class="line">a &#x3D; data.drop_duplicates(&quot;最高气温&quot;)#按表中重复值 而不是上面一个 将他删除&#39;&#39;</span></pre></td></tr></table></figure><h3 id="爬虫生成表"><a href="#爬虫生成表" class="headerlink" title="爬虫生成表"></a>爬虫生成表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;xueqiu.csv&quot;,&quot;w+&quot;,encoding&#x3D;&quot;utf-8_sig&quot;) as f:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w &#x3D; csv.writer(f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cname &#x3D; [&quot;股票代码&quot;,&quot;股票名称&quot;,&quot;当前价&quot;,&quot;成交额&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w &#x3D; csv.DictWriter(f,cname)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.writeheader()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for i in j_text:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w.writerow(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;股票代码&quot;:i[&#39;symbol&#39;],</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;股票名称&quot;:i[&#39;name&#39;],</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;当前价&quot;:i[&#39;current&#39;],</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &quot;成交额&quot;:i[&#39;amount&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分析</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20191217-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据分析采用Python语言用anacodna集成的环境</p><a id="more"></a><h3 id="deepin安装anacodna"><a href="#deepin安装anacodna" class="headerlink" title="deepin安装anacodna"></a>deepin安装anacodna</h3><p><a href="https://www.anaconda.com/download/#linux" target="_blank" rel="noopener">anacodna下载地址</a><br>输入bashAnaconda3-5.1.0-Linux-x86_64.sh<br>回车继续，然后读取许可证，之后会出现More,一直回车继续<br>一直输入yes<br>来到源文件，目录为上图appending后面的 /home/ppl/ .bashrc<br>验证是否安装：conda list<br>创建环境：conda create –namemy_python python=3（python3版本）<br>中间询问，输入y<br>激活环境并添加其他包，例如requests<br>首先更新conda：conda update conda<br>再更新anaconda：conda update anaconda<br>弄完会进入虚拟环境</p><h3 id="数据分析-主要使用"><a href="#数据分析-主要使用" class="headerlink" title="数据分析 主要使用"></a>数据分析 主要使用</h3><p>主要是俩个包<br>NiumPy 高性能计算和数据分析的基础包<br>pandas 属于NiumPy的工具，主要做数据挖掘和数据分析，同时也提供数据清洗</p><h4 id="pandas操作"><a href="#pandas操作" class="headerlink" title="pandas操作"></a>pandas操作</h4><p>df = pd.read_csv(“taobao_data.csv”)#选择要操作的文件<br>df[0:3]前三行函数<br>df.head(0)#前五条数据<br>新建一个文件 名称 保存的字段名 索引为false 编码为utf-8 #header是否保留列名<br>df.to_csv(“./taobaodata.csv”,columns=[“宝贝”,”价格”],index=False,encoding=’utf-8_sig’,header=False)<br>newdf = pd.read_csv(“./taobaodata.csv”) #写入文件<br>df[[“卖家”,”位置”]] #显示俩列<br>df.loc[0:3,[“价格”,”成交量”]]# ix被抛弃 可用ioc显示 列数前三行<br>df[“销售额”] =df[‘价格’]*df[‘成交量’] #建立一个新的变量<br>df[df[“销售额”]&gt;2000000].sort_index()#选择销售额大于20000000的<br>df1=df.set_index(“位置”)<br>df1=df1.sort_index()# 以位置索引<br>df2=df.set_index([“位置”,”卖家”]).sortlevel(0)#根据位置和卖家 deepin上运行失败<br>df.info() #查看文件结构<br>df.describe()</p><h4 id="NiumPy"><a href="#NiumPy" class="headerlink" title="NiumPy"></a>NiumPy</h4><p>list_a=[1,2,3,4,5]#数组<br>ARR=np.array([2,2,3,4,5])#定义数组<br>print(type(list_a),type(ARR))#查看类型</p><blockquote><p>结果&lt;class ‘list’&gt; &lt;class ‘numpy.ndarray’&gt;<br>np.zeros(5,dtype=int)设置五个int,0<br>np.ones(5,dtype=int)设置五个int,1<br>np.random.randn(5) #随机数五个零到一<br>list_a=[[1,2,3],[2,4,6]]#二维数组<br>arr_c.dtype#类型<br>arr_c.size#个数<br>arr_c.shape#z轴<br>矩阵<br>arr_d=np.array([[1,2],[3,4]])<br>arr_e=np.array([[5,6],[7,8]])#矩阵相加 大小相同<br>arr_d*arr_e#矩阵乘法<br>np.sort(a)#排序<br>-np.sort(-a)#逆序</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin BUG</title>
    <url>/deepin/20191216-deepin.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在deepin开发下的各种问题</p><a id="more"></a><p>当系统卡死时不要乱按开机键强关系统，可以优雅的按 Alt+SysRq+R+S+E+I+U+B 进行安全重启（Alt+SysRq要一直按着）<br>###系统源</p><blockquote><p>deb [by-hash=force] <a href="http://packages.deepin.com/deepin" target="_blank" rel="noopener">http://packages.deepin.com/deepin</a> panda main contrib non-free<br>deb-src <a href="http://packages.deepin.com/deepin" target="_blank" rel="noopener">http://packages.deepin.com/deepin</a> panda main contrib non-free</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>appium</title>
    <url>/%E5%B7%A5%E5%85%B7/20191216-null.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>安装手机自动化爬取工具</p><a id="more"></a><p><a href="https://www.cnblogs.com/windhome/p/8024835.html" target="_blank" rel="noopener">deepin安装</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>后记</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Fidder</title>
    <url>/%E5%B7%A5%E5%85%B7/20191216-Fidder.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>Fidder在Linux软件运行比较少 可用wireshark代替</p><a id="more"></a><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium使用二</title>
    <url>/%E5%B7%A5%E5%85%B7/20191216-Selenium%E4%BD%BF%E7%94%A8%E4%BA%8C.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>多个选项卡切换</p><a id="more"></a><p>from selenium import webdriver<br>import time<br>back() 后退 forward() 前进 close() 关闭</p><p>####Cookie<br>获取，添加，删除Cookies add_cookie(cookie_dict) 添加一个cookie。必须有name 和value 值。 get_cookie(name) 按name获取单个Cookie，没有则返回None。 get_cookies() 获取所有Cookie，返回的是一组字典。 delete_cookie(name) 按name删除指定cookie。 delete_all_cookies() 删除所有Cookies</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>from selenium.common.exceptions import TimeoutException,NoSuchElementException<br>browser = webdriver.Chrome(r”C:\Users\Administrator\Desktop\chromedriver.exe”)<br>finally:#为了保证无论出现什么情况,finally块里的代码一定会被执行。<br>browser.close()</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>deepin</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium使用</title>
    <url>/%E5%B7%A5%E5%85%B7/20191216-Selenium.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作，不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）</p><a id="more"></a><h3 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a>PhantomJS</h3><p>无界面浏览器 高版本不支持</p><h3 id="安装调试"><a href="#安装调试" class="headerlink" title="安装调试"></a>安装调试</h3><p>pip install selenium 安装Selenium<br>下载Chromedirver 根据谷歌浏览器版本下载<br><a href="https://docs.python.org/zh-cn/3/library/index.html" target="_blank" rel="noopener">下载地址</a></p><blockquote><p>sudo mv -f chromedriver /usr/local/share/chromedriver<br>sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver<br>sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedrive<br>安装后确认/usr/bin目录下是否有chromedriver文件</p></blockquote><h3 id="Python中使用"><a href="#Python中使用" class="headerlink" title="Python中使用"></a>Python中使用</h3><p>实例化参数<br>chrome_options = Options()<br>browser = webdriver.Chrome(chrome_options=chrome_options)<br>其他启动项：</p><blockquote><p>selenium支持很多浏览器，比如谷歌，火狐，无界面浏览器PhantomJS等等<br>使用方法：</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span></pre></td></tr><tr><td class="code"><pre><span class="line">browser = webdriver.Chrome(<span class="string">r"C:\Users\Administrator\Desktop\chromedriver.exe"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">browser = webdriver.Firefox()</span></pre></td></tr></table></figure><p>chromedriver.exe放到我们的项目目录中，然后在初始化Chrome Webdriver对象时，传入chromedriver.exe的路径。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>browser.get(“<a href="https://www.taobao.com/&quot;" target="_blank" rel="noopener">https://www.taobao.com/&quot;</a>)<br>browser.execute_script(“window.open()”) #调用execute_script方法，传入语句，开启新的选项卡。此处是为了显示close()和quit() 的不同，前者关闭当前选项卡，后者是所有。</p><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_element_by_id #id</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element #元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element_by_css_selector(&quot;#q&quot;) # 选择器</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element_by_xpath#</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element_by_class_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element_by_tag_name#标签名</span></pre></td></tr><tr><td class="code"><pre><span class="line">find_element_by_link_text#链接文本</span></pre></td></tr></table></figure><h4 id="多个几点"><a href="#多个几点" class="headerlink" title="多个几点"></a>多个几点</h4><p>如果要查找目标在网页中只有一个，那么完全可以用findelement()方法。但如果有多个节点，在使用这个方法的话，只能给出一个结果，那么我们可以使用find_elements_by*，其实就是在原来的基础上给element加了个s。<br>find_element()，find_elements()方法</p><h4 id="方法使用"><a href="#方法使用" class="headerlink" title="方法使用"></a>方法使用</h4><p>clear() 如果当前元素中有文本，则清空文本<br>click() 单击当前元素<br>submit()提交表单<br>get_attribute(name) 获取元素的attribute/property优先返回完全匹配属性名的值，如果不存在，则返回属性名中包含name的值。<br>screenshot(filename) 获取当前元素的截图，保存为png，最好用绝对路径。此方法在Chrome中无法使用。<br>save_screenshot(filename) 该方法直接保存当前屏幕截图到当前脚本所在文件位置。<br>send_keys(value) 模拟输入内容</p><h4 id="模拟键盘"><a href="#模拟键盘" class="headerlink" title="模拟键盘"></a>模拟键盘</h4><blockquote><p>from selenium import webdriver<br>from selenium.webdriver.common.keys import Keys<br>send_keys(Keys.RETURN) #模拟键盘Enter键提交搜索需求<br>driver.find_element_by_id(“kw”).send_keys(Keys.CONTROL, ‘a’)#ctrl+a 全选输入框内容</p></blockquote><h4 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h4><p>有时候我们需要类似于拖动，双击，长按等等。这个时候就需要用到我们的Action Chains（动作链）了。</p><blockquote><p>from selenium import webdriver<br>from selenium.webdriver import ActionChains</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x3D; browser.find_element_by_id(&quot;draggable&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">target &#x3D; browser.find_element_by_css_selector(&quot;#droppable&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">actions &#x3D; ActionChains(browser)</span></pre></td></tr><tr><td class="code"><pre><span class="line">actions.drag_and_drop(source,target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">actions.perform() #执行</span></pre></td></tr></table></figure><h5 id="常用动作方法"><a href="#常用动作方法" class="headerlink" title="常用动作方法"></a>常用动作方法</h5><p>action.keyDown(Keys.CONTROL); #按下 Ctrl 键<br>action.keyUp(Keys.ALT); #释放 Alt 键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">click_and_hold(on_element&#x3D;None)  点击并抓起</span></pre></td></tr><tr><td class="code"><pre><span class="line">double_click(on_element&#x3D;None) 双击。</span></pre></td></tr><tr><td class="code"><pre><span class="line">drag_and_drop_by_offset(source, xoffset, yoffset) 在source元素上点击抓起，移动到相对于source元素偏移xoffset和yoffset的坐标位置放下。</span></pre></td></tr><tr><td class="code"><pre><span class="line">drag_and_drop(source, target)  在source元素上点击抓起，移动到target元素上松开放下。</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_down(self, value, element&#x3D;None)    某个键盘键被按下</span></pre></td></tr><tr><td class="code"><pre><span class="line">key_up(self, value, element&#x3D;None)    松开某个键</span></pre></td></tr><tr><td class="code"><pre><span class="line">send_keys(*keys_to_send)  将键发送到当前聚焦的元素。</span></pre></td></tr><tr><td class="code"><pre><span class="line">send_keys_to_element(element, *keys_to_send) 将键发送到指定的元素。</span></pre></td></tr><tr><td class="code"><pre><span class="line">reset_actions() 清除已经存储的动作。</span></pre></td></tr></table></figure><h3 id="执行js"><a href="#执行js" class="headerlink" title="执行js"></a>执行js</h3><p>execute_async_script(script, *args)script：要执行的JS代码。args：JS代码执行要传入的参数</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>deepin</tag>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin下搭建博客二</title>
    <url>/deepin/20191216-blog2.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>seo优化由于github禁用百度爬虫 所以用国内发布 coding来进行搭建seo优化 写作的模板地址</p><a id="more"></a><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>搭建 coding 仓库 和github一样 名字设置为 coding.me 不然百度无法绑定</p><h4 id="双仓库的设置"><a href="#双仓库的设置" class="headerlink" title="双仓库的设置"></a>双仓库的设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - type: git # 原来就有的</span></pre></td></tr><tr><td class="code"><pre><span class="line">    repo: </span></pre></td></tr><tr><td class="code"><pre><span class="line">        github: https:&#x2F;&#x2F;github.com&#x2F;zlloong&#x2F;LoongBoke.git </span></pre></td></tr><tr><td class="code"><pre><span class="line">        coding: https:&#x2F;&#x2F;git.dev.tencent.com&#x2F;ermao7&#x2F;ermao7.coding.me.git </span></pre></td></tr><tr><td class="code"><pre><span class="line">    branch: master</span></pre></td></tr><tr><td class="code"><pre><span class="line">    message: blog update</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  - type: baidu_url_submitter # 注意，这个为新增的</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">baidu_url_submit:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  count: 100 ## 比如100，代表提交最新的一百个链接</span></pre></td></tr><tr><td class="code"><pre><span class="line">  host: ermao7.coding.me ## 在百度站长平台中注册的域名</span></pre></td></tr><tr><td class="code"><pre><span class="line">  token: 0P1O2j0ZwUzkVuLw ## 刚刚复制的秘钥，不要公布到任何地方。</span></pre></td></tr><tr><td class="code"><pre><span class="line">  path: baidu_urls.txt ## 文本文档的地址，新链接会保存在此文本文档里</span></pre></td></tr></table></figure><h3 id="seo优化步骤"><a href="#seo优化步骤" class="headerlink" title="seo优化步骤"></a>seo优化步骤</h3><h4 id="百度收录站点"><a href="#百度收录站点" class="headerlink" title="百度收录站点"></a>百度收录站点</h4><p>选择关键字 html文件利用hexo生成<br>自动生成sitmap 插件用来自动提交</p><blockquote><p>npm install hexo-generator-sitemap –save</p></blockquote><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>自动推送<br>baidu_push: true 在配置文件更改<br>用来推送的插件</p><blockquote><p>npm install hexo-baidu-url-submit –save</p></blockquote><h4 id="百度爬虫的君子协议-选择爬虫的范围"><a href="#百度爬虫的君子协议-选择爬虫的范围" class="headerlink" title="百度爬虫的君子协议 选择爬虫的范围"></a>百度爬虫的君子协议 选择爬虫的范围</h4><p>新建一个robots.txt文件，添加以下内容，然后放到/zzz/source/文件夹下面</p><blockquote><p>User-agent: *<br>Allow: /<br>Allow: /archives/<br>Allow: /tags/<br>Allow: /categories/<br>Allow: /about/</p></blockquote><p>Disallow: /js/</p><blockquote><p>Disallow: /css/<br>Disallow: /lib/</p><p>Sitemap: ermao7.coding.me/sitemap.xml</p></blockquote><h4 id="设置网站的级别-让爬虫更好爬取"><a href="#设置网站的级别-让爬虫更好爬取" class="headerlink" title="设置网站的级别 让爬虫更好爬取"></a>设置网站的级别 让爬虫更好爬取</h4><p>设置主目录配置 文件级别目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :category&#x2F;:year:month:day-:urlname.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">permalink_defaults: </span></pre></td></tr><tr><td class="code"><pre><span class="line">  urlname: index</span></pre></td></tr></table></figure><h3 id="写作模板"><a href="#写作模板" class="headerlink" title="写作模板"></a>写作模板</h3><p>写作模板是yoursite/scaffolds/post.md，这个文件。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql高级</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/20191213-MySQL%E9%AB%98%E7%BA%A7.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>多表联查　事物处理　表复制　视图　函数</p><a id="more"></a><h3 id="MySQL的多表联查"><a href="#MySQL的多表联查" class="headerlink" title="MySQL的多表联查"></a>MySQL的多表联查</h3><p>嵌套查询 不推荐</p><h3 id="where关联查询"><a href="#where关联查询" class="headerlink" title="where关联查询"></a>where关联查询</h3><p>select s.*,c.name cname from stu s,classes c where s.classid=c.id;<br>用 where 将俩个表关联起来<br>例子</p><blockquote><ul><li>统计每个班级的人数<br>mysql&gt; select c.name,count(s.id) from classes c,stu s where c.id=s.classid group by c.id;<br>join连接查询（左联，右联，内联）</li></ul></blockquote><h3 id="JOIN连接查询（左联，右联，内联）"><a href="#JOIN连接查询（左联，右联，内联）" class="headerlink" title="JOIN连接查询（左联，右联，内联）"></a>JOIN连接查询（左联，右联，内联）</h3><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。<br>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。<br>RIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。<br>select n.id,n.title,t.name from news n,ntype t where n.ntid=t.id<br>select n.id,n.title,t.name from news n inner join ntype t on n.ntid=t.id;</p><h3 id="事物处理"><a href="#事物处理" class="headerlink" title="事物处理"></a>事物处理</h3><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。<br>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。<br>事务用来管理 insert,update,delete 语句<br>开启事务<br>BEGIN;<br>执行sql…<br>成功执行 事务提交<br>commit<br>失败执行 事务回滚<br>rollback<br>将多条sql操作（增删改）看成一个操作单元，要么都成功，要么都失败<br>注意：用了事务，就不可避免的牺牲一部分速度，来保证数据的正确性。<br>SET AUTOCOMMIT=0 禁止自动提交<br>SET AUTOCOMMIT=1 开启自动提交<br>｀｀｀</p><ol><li>set autocommit = 0;</li><li>增删改语句</li><li>savepoint aaa; //设置保存点</li><li>继续执行语句</li><li>savepoint bbb;</li><li>rollback to aaa; 回滚到aaa;</li><li>commit<br>｀｀｀<h3 id="索引和视图"><a href="#索引和视图" class="headerlink" title="索引和视图"></a>索引和视图</h3>PRIMARY（主键）, INDEX（普通索引）, UNIQUE（唯一索引　不允许重复） 这3种是一类<br>FULLTEXT 是全文索引，用于在一篇文章中，检索文本信息的<br>但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件<br>SHOW INDEX FROM table_name; \G　显示索引信息　Ｇ格式化输出信息<br>视图　创建表后面添加ｖｉｅｗ<br>？　ｖｉｅｗ　帮助信息<h4 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h4>create table 目标表名 like 原表名;<br>insert into 目标表名 select * from 原表名; /* 求目标表存在*/<h3 id="函数常用"><a href="#函数常用" class="headerlink" title="函数常用"></a>函数常用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abs(x) 返回x的绝对值</span></pre></td></tr><tr><td class="code"><pre><span class="line">round(x)进行四舍五入处理以后，只保留了各个值的整数部分。</span></pre></td></tr><tr><td class="code"><pre><span class="line">now() 返回当前日期和时间,</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix_timestamp(date) 返回date时间的unix时间戳</span></pre></td></tr><tr><td class="code"><pre><span class="line">date_fomat(date,fmt) 返回按字符串fmt格式化日期date值</span></pre></td></tr><tr><td class="code"><pre><span class="line">datediff(expr,expr2) 返回起始时间和结束时间的间隔天数</span></pre></td></tr><tr><td class="code"><pre><span class="line">FROM_UNIXTIME()   UNIX时间戳转换为日期用函数</span></pre></td></tr><tr><td class="code"><pre><span class="line">统计时间戳647583423距离当前时间相差天数（生日天数（不考虑年份））</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql&gt; select datediff(date_format(from_unixtime(647583423),&quot;2017-%m-%d %h:%i:%s&quot;),now());</span></pre></td></tr><tr><td class="code"><pre><span class="line">*database() 返回当前数据库名</span></pre></td></tr><tr><td class="code"><pre><span class="line">version() 返回当前服务器版本</span></pre></td></tr><tr><td class="code"><pre><span class="line">user()    返回当前登陆用户名</span></pre></td></tr><tr><td class="code"><pre><span class="line">inet_aton 返回当前IP地址的数字表示 inet_aton(&quot;192.168.80.250&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">inet_ntoa(num) 返回当前数字表示的ip inet_ntoa(3232256250);</span></pre></td></tr><tr><td class="code"><pre><span class="line">password(str) 返回当前str的加密版本</span></pre></td></tr><tr><td class="code"><pre><span class="line">md5(str) 返回字符串str的md5值</span></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql2</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/20191213-MySQL2.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>MySQL 数据操作 DML</p><blockquote><p>数据的DML操作：添加数据，修改数据，删除数据</p></blockquote><a id="more"></a><h3 id="增加-insert"><a href="#增加-insert" class="headerlink" title="增加 insert"></a>增加 insert</h3><pre><code>insert into 表名[(字段列表)] values(值列表...)
插入单行的时候使用VALUES，在插入多行的时候使用VALUE 这样比较快一点</code></pre><p>批量添加用逗号分隔 在value后</p><h3 id="修改-update"><a href="#修改-update" class="headerlink" title="修改 update"></a>修改 update</h3><pre><code>update 表名 set 字段1=值1,字段2=值2,字段n=值n... where 条件</code></pre><h3 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除 delete"></a>删除 delete</h3><pre><code>elete from 表名 [where 条件]
between 20 and 30 区间and</code></pre><h3 id="查询-selelct"><a href="#查询-selelct" class="headerlink" title="查询 selelct"></a>查询 selelct</h3><p>select * from stu;</p><h3 id="WHERE条件"><a href="#WHERE条件" class="headerlink" title="WHERE条件"></a>WHERE条件</h3><p>你可以在 WHERE 子句中指定任何条件。 你可以使用 AND 或者 OR 指定一个或多个条件。 WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。 WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</p><h4 id="like字句-模糊查找"><a href="#like字句-模糊查找" class="headerlink" title="like字句 模糊查找"></a>like字句 模糊查找</h4><p>–9. 查询name字段值是以zh开头的所有信息<br>select * from stu where name like “zh%”;<br>select * from stu where name regexp “^zh”; –正则写法</p><p>–11. 查询姓名是任意四位字符构成的信息。</p><blockquote><p>mysql&gt; select * from stu where name like “____”;<br>mysql&gt; select * from stu where name regexp “^[a-z0-9]{4}$”;</p></blockquote><h3 id="MySQL的统计函数（聚合函数）"><a href="#MySQL的统计函数（聚合函数）" class="headerlink" title="MySQL的统计函数（聚合函数）"></a>MySQL的统计函数（聚合函数）</h3><p>max() min() count() sum() avg()<br>获取学生表中最大、最小以及平均年龄是多少？<br>mysql&gt; select max(age),min(age),avg(age) from stu; 函数可以用在字段<br>– 获取学生表中男生m的数量<br>mysql&gt; select count(*) from stu where sex=’m’;</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>GROUP BY 语句 分组<br>###ORDER BY 排序 – asc 默认升序 desc 降序<br>select * from stu order by age asc; –默认asc升序 可省略<br>– 查询学生信息，按班级做升序排序，相同班级按年龄降序排序<br>mysql&gt; select * from stu order by classid asc,age desc;</p><h3 id="页数"><a href="#页数" class="headerlink" title="页数"></a>页数</h3><p>limit 关键字 查询部分数据<br>mysql&gt; select * from stu limit 5; 前五条<br>– 排除前2条后再获取4条信息<br>mysql&gt; select * from stu limit 2,4;</p><p>页号 limit语句 起始分页码数值是页大小的几倍。<br>页数为起始分页码数值是页大小的几倍</p><h3 id="数据库导出导入"><a href="#数据库导出导入" class="headerlink" title="数据库导出导入"></a>数据库导出导入</h3><blockquote><p>– 将lamp138库导出<br>D:&gt;mysqldump -u root -p lamp138 &gt;lamp138.sql<br>Enter password:<br>—- 将lamp138库中的stu表导出<br>D:&gt;mysqldump -u root -p lamp138 stu &gt;lamp138_stu.sql<br>Enter password:</p></blockquote><blockquote><p>– 将lamp138库导入<br>D:&gt;mysql -u root -p lamp138&lt;lamp138.sql<br>Enter password:<br>– 将lamp138库中stu表导入<br>D:&gt;mysql -u root -p lamp138&lt;lamp138_stu.sql<br>Enter password:</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/20191213-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>Mysql是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一</p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="deepin安装删除"><a href="#deepin安装删除" class="headerlink" title="deepin安装删除"></a>deepin安装删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install mysql-client</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install libmysqlclient-dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql -u root -p 你的密码</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt purge mysql-*</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo rm -rf &#x2F;etc&#x2F;mysql&#x2F; &#x2F;var&#x2F;lib&#x2F;mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt autoremove</span></pre></td></tr></table></figure><h4 id="允许远程访问"><a href="#允许远程访问" class="headerlink" title="允许远程访问"></a>允许远程访问</h4><p>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf<br>释掉bind-address = 127.0.0.1</p><h4 id="用户访问"><a href="#用户访问" class="headerlink" title="用户访问"></a>用户访问</h4><p>grant all privileges on 库名.表名 to ‘用户名‘@’IP地址’ identified by ‘密码’ [with grant option];<br>grant all on <em>.</em> to root@’%’ identified by ‘123456’ with grant option; 百分号代表随意<br>drop user 账号@来源 ​drop user ‘xxoo’@’%’ 删除用户<br>service mysql restart 重启</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>SQL语言分为4个部分：DDL（定义）、DML（操作）、DQL（查询）、DCL（控制）</p><blockquote><p>查看数据库 show databases;<br>创建数据库 create database 库名 default charset=utf8;<br>删除数据库 drop database 库名;<br>打开数据库 use 库名;<br>创建表: create table 表名(字段名1 类型,字段名2 类型)engine=innodb default charset=utf8;<br>​删除表: drop table 表名;<br>​表结构: desc 表名;</p></blockquote><h5 id="插入库"><a href="#插入库" class="headerlink" title="插入库"></a>插入库</h5><p>create database if not exists UNOOB default charset utf8;<br>如果数据库不存在则创建，存在则不创建。 创建UNOOB数据库，并设定编码集为UTF8</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id int unsigned not null AUTO_INCREMENT PRIMARY KEY,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        username varchar(30) not null,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        password char(32) not null,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        email varchar(100) not null,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pic varchar(50) default &#39;.&#x2F;public&#x2F;img&#x2F;pic.jpg&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    )engine&#x3D;innodb default charset&#x3D;utf8;</span></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><p>alter table 表名 add 字段名信息<br>alter table user add num int not null; 在后面添加属性 在字段后面添加 最后写 after 字段名 最前面添加 最后写 first<br>alter table 表名 drop 被删除的字段名<br>alter table 表名 change[modify] 被修改后的字段信息<br>其中：change可以修改字段名， modify 不修改 modify 只修改字段信息<br>DROP TABLE table_name ;删除表</p><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><p>为user表中的name字段添加唯一性索引，索引名为uni_name;<br>alter table user add unique uni_name(name);<br>为user表中的email字段添加普通索引，索引名为index_eamil<br>alter table user add index index_email(email);<br>将user表中index_email的索引删除<br>alter table user drop index index_email;</p><h4 id="修改表名字"><a href="#修改表名字" class="headerlink" title="修改表名字"></a>修改表名字</h4><p>ALTER TABLE 旧表名 RENAME AS 新表名<br>ALTER TABLE 原表名 RENAME 新表名<br>RENAME TABLE 原表名 to 新表名<br>nsert into 表名(字段1,字段2,字段3) values(值1,值2,值3); insert into 表名(字段1,字段2,字段3) values(a值1,a值2,a值3),(b值1,b值2,b值3);<br>插入单行的时候使用VALUES，在插入多行的时候使用VALUE 这样比较快一点</p><h3 id="俩种引擎的性能"><a href="#俩种引擎的性能" class="headerlink" title="俩种引擎的性能"></a>俩种引擎的性能</h3><p>总的来说，MyISAM和InnoDB各有优劣，各有各的使用环境。<br>但是InnoDB的设计目标是处理大容量数据库系统，它的CPU利用率是其它基于磁盘的关系数据库引擎所不能比的。<br>我觉得使用InnoDB可以应对更为复杂的情况，特别是对并发的处理要比MyISAM高效。同时结合memcache也可以缓存SELECT来减少SELECT查询，从而提高整体性能</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Django应用1</title>
    <url>/Djang/20191209-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>开发视频网站</p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>采取用户处理分块模式为注册单独设定一个独立框架文件</p><h3 id="实现用户登录逻辑"><a href="#实现用户登录逻辑" class="headerlink" title="实现用户登录逻辑"></a>实现用户登录逻辑</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ol><li>首先在models实现模型设置定义所需要的类和参数然后进行数据库迁移</li><li>在前端模板放入前端写好的前端页面</li><li>将js css 图片等数据 放入static 进行静态加载</li><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端页面调用 &#123;% load static %&#125;  &quot;&#123;%static &#39;文件下路径&#39;%&#125;&quot;加载</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">python3 manage.py runserver --insecure</span></pre></td></tr></table></figure></li><li>前端页面传输数据返回给路由由传输到views.来进行数据判断<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&#123;% url &#39;users:signup&#39; %&#125;&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">form.password2 #接收参数</span></pre></td></tr></table></figure></li><li>views接收参数 检查是否为post请求<br>然后进行校验</li><li>form = SignUpForm(request.POST)</li><li>建立一个类 form校验类<br>通过传输数据来进行判断是否有错误<br>有错误return出去错误信息<br>没有错误传输到数据库<br>没有参数new一个新的值给from<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error_messages &#x3D; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#39;invalid_login&#39;: &quot;两次密码不一样&quot;, &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   username &#x3D; forms.CharField(</span></pre></td></tr><tr><td class="code"><pre><span class="line">       error_messages&#x3D;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &quot;required&quot;: &quot;用户名不为空&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">       widget&#x3D;forms.TextInput(attrs&#x3D;&#123;&#39;placeholder&#39;: &quot;请输入用户名&quot;&#125;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">   )</span></pre></td></tr></table></figure><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4></li><li>建立前段文件 同理注册传输数据</li><li>路由传输到view.log方法进行验证</li><li>验证成功返回和数据库进行比对成功进入不成功返回错误信息</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Djang</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web开发</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则</title>
    <url>/JS/20191209-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串,<br>正则表达式通常被用来检索、替换那些符合某个模式的文本</p><a id="more"></a><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用RegExp的显式构造函数，语法为：</span></pre></td></tr><tr><td class="code"><pre><span class="line">new RegExp(&quot;pattern&quot;[,&quot;flags&quot;])</span></pre></td></tr><tr><td class="code"><pre><span class="line">使用RegExp的隐式构造函数，采用纯文本格式：</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;pattern&#x2F;[flags]</span></pre></td></tr></table></figure><h3 id="关键子"><a href="#关键子" class="headerlink" title="关键子"></a>关键子</h3><p>g是全局标志。如果设置了这个标志，对某个文本执行搜索和替换操作时，将对文本中所有匹配的内容起作用。如果不设置这个标志，则仅搜索和替换最早匹配的内容（即第一个）。</p><p>i是忽略大小写标志。如果设置了这个标志，进行匹配比较时，将忽略大小写。</p><p>m是多行标志。如果不设置这个标志，那么元字符“ ^”只与整个被搜索字符串的开始位置相匹配，而元字符“$“只与被搜索字符串的结束位置相匹配。如果设置了这个标志，“ ^ ”还可以与被搜索字符串中的“\n”或“\r”之后的位置（即下一行的行首）相匹配，而“$”还可以与被搜索字符串中的“\n”或“\r”之后的位置（即下一行的行尾）相匹配。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\w  \W  \d  \D  \s  \S  </span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\w&#x2F;;&#x2F;&#x2F;单个的字母数字下划线</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\W&#x2F;;&#x2F;&#x2F;单个的非字母数字下划线</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d&#x2F;;&#x2F;&#x2F;单个数字字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\D&#x2F;;&#x2F;&#x2F;单个非数字字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\s&#x2F;;&#x2F;&#x2F;单个空白字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\S&#x2F;;&#x2F;&#x2F;单个的非空白字符</span></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. * + ? &#123;&#125; [] () | ^ $</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;.&#x2F;;&#x2F;&#x2F;除了换行外的其它任意字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;z*&#x2F;;&#x2F;&#x2F;匹配0次或多次</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;z+&#x2F;;&#x2F;&#x2F;匹配至少1次或多次</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\w+?&#x2F;;&#x2F;&#x2F;禁止贪婪 </span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\w&#123;5&#125;&#x2F;;&#x2F;&#x2F;限制匹配的次数</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\w&#123;5,12&#125;&#x2F;;&#x2F;&#x2F;限制匹配5到12次</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;[a-zA-Z0-9]+&#x2F;;&#x2F;&#x2F;字符范围</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;\d+(\w+)\w+&#x2F;;&#x2F;&#x2F;子组  下标为0的是返回所有，1以后才是分组内容 length是返回的个数</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;abc|def|123&#x2F;;&#x2F;&#x2F;或</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;^\$&#x2F;;&#x2F;&#x2F;限制开始</span></pre></td></tr><tr><td class="code"><pre><span class="line">var reg &#x3D; &#x2F;a$&#x2F;;&#x2F;&#x2F;限制结尾</span></pre></td></tr></table></figure><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>exec(string),对string进行正则处理,并返回匹配结果.该方法使用创建RegExp对象实例时所指定的表达式模式对一个字符串进行搜索，并返回一个包含搜索结果的数组。如果 exec 方法没有找到匹配，将返回 null。<br>test(string),测试string是否含有匹配结果,如果存在就返回True，否则返回False。</p><h4 id="表达式方法"><a href="#表达式方法" class="headerlink" title="表达式方法"></a>表达式方法</h4><p>String正则表达方法<br>match(pattern) 根据pattern进行正则匹配,如果匹配到,返回匹配结果,如匹配不到返回null<br>search(pattern) 根据pattern进行正则匹配,如果匹配到一个结果,则返回它的索引数;否则返回-1<br>replace(pattern,replacement) 根据pattern进行正则匹配,把匹配结果替换为replacement,该方法并不改变调用它的字符串本身，而只是返回替换后的字符串。<br>split(pattern) 根据pattern进行正则分割,返回一个分割的数组<br>胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏毅胡宏</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JS2</title>
    <url>/JS/20191209-js2.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>JS 高级应用</p><a id="more"></a><h3 id="JS函数"><a href="#JS函数" class="headerlink" title="JS函数"></a>JS函数</h3><p>1.function abc(){<br>2.第二种是在表达式中定义函数 var 函数名 = function(参数1，参数2，…){函数体}; 推荐： 匿名函数表达式 var 函数名 = function 函数名（可写可不写）(参数1，参数2，…){函数体}; 命名函数表达式（赋值表达）</p><blockquote><p>1.以函数声明的方法定义的函数，函数名是必须的，而函数表达式的函数名是可选的。<br>2.以函数声明的方法定义的函数，函数可以在函数声明之前调用，而函数表达式的函数只能在声明之后调用。<br>3.以函数声明的方法定义的函数并不是真正的声明，他们仅仅可以出现在全局中或者嵌套在其它函数中</p></blockquote><p>这就要从JavaScript解释引擎机制上说了! 在采用定义式创建同名函数时，后创建的函数会覆盖先创建的函数。这种差别是由于JavaScript解释引擎的工作机制所导致的。JavaScript解释引擎在执行任何函数调用之前，首先会在全局作用域中注册以定义式创建的函数，然后再依次执行函数调用。由于注册函数时，后定义的函数重写了先定义的函数，因此无论调用语句位于何处，执行的都是后定义的函数。</p><p>对于声明式创建的函数，JavaScript解释引擎会像对待任何声明的变量一样，等到执行调用该变量的代码时才会对变量求值。由于JavaScript代码是从上到下顺序执行的，因此当执行第一个a()调用时，a函数的代码就是首先定义代码；而当执行第二个a()调用时，a函数的代码又变成了后来定义的代码</p><p>在函数代码中，使用特殊对象 arguments，开发者 无需明确指出参数名，就能访问它们。<br>关于变量和参数问题：<br>函数外面定义的变量是全局变量，函数内可以直接使用。<br>在函数内部没有使用var定义的变量则为全局变量，<br>*在函数内使用var关键字定义的变量是局部变量，即出了函数外边无法获取。<br>js函数定义的参数没有默认值,(</p><h3 id="JS-对象"><a href="#JS-对象" class="headerlink" title="JS 对象"></a>JS 对象</h3><p>JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。<br>属性是与对象相关的值。<br>方法是能够在对象上执行的动作。<br>1.self 指当前窗口对象 （指窗口本身，返回的对象跟windows对象是一样的）<br>2.this 指当前对象</p><h3 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型:"></a>测试类型:</h3><p>1.typeof() //global对象的其中一个方法，typeof()<br>2.对象.constructor; //查看当前对象的构造函数是谁</p><p>if(arr.constructor==Array){<br>alert(“数组”); //数组推荐用这种方法，因为typeof得到是object<br>}</p><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>var aList = new Array(1,2,3);<br>3、push() 和 pop() 从数组最后增加成员或删除成员<br>4、unshift()和 shift() 从数组前面增加成员或删除成员<br>6.sort() 升序排列数组<br>7.reverse() 反转数组项的顺序。<br>8.slice() 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。</p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>同Java Python Math</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JS</title>
    <url>/JS/20191209-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>JavaScript是运行在浏览器端的脚本语言，JavaScript主要解决的是前端与用户交互的问题，包括使用交互与数据交互。 JavaScript是浏览器解释执行的，前端脚本语言还有JScript（微软，IE独有），ActionScript( Adobe公司，需要插件)等。</p><a id="more"></a><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>//同时定义多个变量可以用”,”隔开，公用一个‘var’关键字<br>Javascript声明变量的时候，虽然用var关键字声明和不用关键字声明，很多时候运行并没有问题，但是这两种方式还是有区别的。可以正常运行的代码并不代表是合适的代码。</p><p>注意！它并不是声明了一个全局变量，而是创建了一个全局对象的属性。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li>boolean - 如果变量是 Boolean 类型的</li><li>number - 如果变量是 Number 类型的 (整数、浮点数)</li><li>string - 如果变量是 String 类型的 （采用””、 ‘’）</li><li>object - 如果变量是一种引用类型或 Null 类型的</li><li>function – 函数类型</li><li>undefined - 如果变量是 Undefined 类型的</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数isNaN()检测参数是否不是一个值为NaN</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;	&amp;运算符我们都知道，只有两个都为真，结果才为真。</span></pre></td></tr><tr><td class="code"><pre><span class="line">l	l与 ll操作符的道理也是一样的，只要两个数中有一个数为1，结果就为1，其他则为0。</span></pre></td></tr><tr><td class="code"><pre><span class="line">^	按位异或是两个数中只有一个1时返回1，其他情况返回0。</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&lt;	有符号左移会将32位二进制数的所有位向左移动指定位数。</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;	有符号右移会将32位二进制数的所有位向右移动指定位数。</span></pre></td></tr><tr><td class="code"><pre><span class="line">?   :    三元运算符</span></pre></td></tr><tr><td class="code"><pre><span class="line">语法是 条件 ? 结果1 : 结果2;.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 这里你把条件写在问号(?)的前面后面跟着用冒号(:)分隔的结果1和结果2。满足条件时结果1否则结果2。</span></pre></td></tr><tr><td class="code"><pre><span class="line">例子：</span></pre></td></tr></table></figure><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><p>if switch dowhile for foreach 都与Java想同</p><h3 id="HTML-渲染"><a href="#HTML-渲染" class="headerlink" title="HTML 渲染"></a>HTML 渲染</h3><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>DOM 是Docunment Object Model （文档对象模型） HTML DOM 是干什么用的? 获取，修改，添加，删除HTML元素的标准 HTML DOM 把html文档做成树结构，被称为节点树，所有事物都是节点。<br>1．解析HTML文件，创建DOM树<br>2．解析CSS,形成CSS对象模型<br>3．将CSS与DOM合并，构建渲染树（renderingtree）<br>4．布局和绘制</p><h4 id="getElementBy函数用法"><a href="#getElementBy函数用法" class="headerlink" title="getElementBy函数用法"></a>getElementBy函数用法</h4><pre><code>getElementById    通过ID获取元素
getElementByName   通过name获取元素
getElementsByTagName   通过标签名
getElementsByClassName  通过class属性值</code></pre><p>可以使用内置对象document上的getElementById方法来获取页面上设置了id属性的元素，获取到的是一个html对象，然后将它赋值给一个变量，比如： ```javascript<br>第二种方法：将javascript语句放到window.onload触发的函数里面,获取元素的语句会在页面加载完后才执行，就不会出错了。 javascript// window 页面当中最大的对象</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><pre><code>setTimeout  只执行一次的定时器 
clearTimeout 关闭只执行一次的定时器
setInterval  反复执行的定时器
clearInterval 关闭反复执行的定时器
setTimeout(code,millisec,lang) - 暂停指定的毫秒数后执行指定的代码 </code></pre><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/deepin/20191208-Markdown.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><a id="more"></a><h3 id="基础语法格式"><a href="#基础语法格式" class="headerlink" title="基础语法格式"></a>基础语法格式</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>1.标题 #号 几个代表几级标题<br>2.水平线 三个* _ - 都可以</p><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><p>1.加粗 俩个* _<br>2.斜线 一个_ *<br>3.粗斜体 三个<br>3.文字带线(删除线) 俩个~<br>4.带下划线可以用 html变迁&lt;\u&gt;</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>无序 + * -<br>有序 1. 2. 3.<br>嵌套 加tap 或者四个空格<br>###区块引用<br>引用是 &gt;加空格<br>嵌套是多家 &gt;加空格嵌套<br>&gt; &gt; &gt; 第二层嵌套<br>列表加区块 加tap 或者四个空格</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>三个<code>包裹 可加名称 \</code>`` more<br>或者 tap 四个空格 退格</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>[链接名称](链接地址)或者&lt;链接地址&gt;<br>链接也可以用变量来代替，俩个方括号 最后调用</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>![alt 属性文本](图片地址 “可选标题”)<br>开头一个感叹号 !<br>接着一个方括号，里面放上图片的替代文字<br>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字<br>也可以用变量</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>| 表头 | 表头 |<br>| —- | —- |<br>| 单元格 | 单元格 |<br>| 单元格 | 单元格 |<br>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br>表头设置<br>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目前支持的 HTML 元素有：&lt;kbd\&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</span></pre></td></tr></table></figure><h4 id="需要转义的"><a href="#需要转义的" class="headerlink" title="需要转义的"></a>需要转义的</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;   反引号</span></pre></td></tr><tr><td class="code"><pre><span class="line">*   星号</span></pre></td></tr><tr><td class="code"><pre><span class="line">_   下划线</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#125;  花括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">[]  方括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">()  小括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">#   井字号</span></pre></td></tr><tr><td class="code"><pre><span class="line">+   加号</span></pre></td></tr><tr><td class="code"><pre><span class="line">-   减号</span></pre></td></tr><tr><td class="code"><pre><span class="line">.   英文句点</span></pre></td></tr><tr><td class="code"><pre><span class="line">!   感叹号</span></pre></td></tr></table></figure><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://www.runoob.com/markdown/md-advance.html" target="_blank" rel="noopener">流程图</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/python/20191208-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>正则表达式本身是一种小型的、高度专业化的编程语言，而在python中，通过内嵌集成re模块，程序猿 们可以直接调用来实现正则匹配。正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。<br><a id="more"></a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>compile()<br>编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）<br>格式：re.compile(pattern,flags=0)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标志	含义</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.S(DOTALL)	使.匹配包括换行在内的所有字符</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.I（IGNORECASE）	使匹配对大小写不敏感</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.L（LOCALE）	做本地化识别（locale-aware)匹配，法语等</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.M(MULTILINE)	多行匹配，影响^和$</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.X(VERBOSE)	该标志通过给予更灵活的格式以便将正则表达式写得更易于理解</span></pre></td></tr><tr><td class="code"><pre><span class="line">re.U 根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</span></pre></td></tr><tr><td class="code"><pre><span class="line">注意： match 和 search 是匹配一次 findall 匹配所有。</span></pre></td></tr></table></figure><h3 id="常用字符所代表的含义-规则前加R防止转义"><a href="#常用字符所代表的含义-规则前加R防止转义" class="headerlink" title="常用字符所代表的含义(规则前加R防止转义)"></a>常用字符所代表的含义(规则前加R防止转义)</h3><p>\d : 匹配一个数字<br>\w : 匹配一个数字字母下划线<br>\s : 匹配空格<br>\D : 匹配非 \d<br>\W : 匹配非 \w<br>\S : 匹配非 \s<br>.: 匹配任意字符,但是不能匹配换行 ,如果加上 re.S 则匹配换行符<br>.<em>? : 非贪婪模式<br>.</em> : 贪婪模式<br><em>: 匹配 0 - N 个</em>号前边的字符<br>+: 匹配 1 - N 个+号前边的字符<br>?: 匹配 0 - 1 个?号前边的字符<br>[] : 任意字符，范围例如[a-zA-Z]所有字符都是原字符（无特殊含义）<br>[^] : 非 []内容里面的字符<br>{n} : 重复 N次<br>{m,n} : 重复 m 到 n 次<br>() : 分组<br>^ : 必须以规则开始<br>$ ：必须以规则结束</p><h3 id="匹配中文的的正则"><a href="#匹配中文的的正则" class="headerlink" title="匹配中文的的正则"></a>匹配中文的的正则</h3><p>title = u’你好，hello，世界’<br>pattern = re.compile(ur’[\u4e00-\u9fa5]+’)<br>result = pattern.findall(title)<br>print (result)<br>注意到，我们在正则表达式前面加上了两个前缀 ur，其中 r 表示使用原始字符串，u 表示是 unicode 字符串。<br>执行结果:<br>[u’\u4f60\u597d’, u’\u4e16\u754c’]</p><h3 id="贪婪模式和非贪婪模式的差别"><a href="#贪婪模式和非贪婪模式的差别" class="headerlink" title="贪婪模式和非贪婪模式的差别"></a>贪婪模式和非贪婪模式的差别</h3><p>决定了尽可能多匹配 b，所以a后面所有的 b 都出现了。<br>使用非贪婪的数量词的正则表达式ab*?，匹配结果： a。<br>即使前面有 *，但是 ? 决定了尽可能少匹配 b，所以没有 b。<br>禁止贪婪不匹配最后一个字符</p><p>使用非贪婪的数量词的正则表达式：</p><div>.*?</div><br>匹配结果：<div>test1</div><br>正则表达式二采用的是非贪婪模式，在匹配到第一个“”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为“<div>test1</div>”。<p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin下搭建博客</title>
    <url>/deepin/20191208-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>在github下构建仓库利用note hexo框架搭建个人博客</p><a id="more"></a><h3 id="构建github仓库"><a href="#构建github仓库" class="headerlink" title="构建github仓库"></a>构建github仓库</h3><p>git init 初始化在当前文文件下</p><h3 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y nodejs</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt-get install -y build-essential</span></pre></td></tr></table></figure><h3 id="安装到文件下设置配置文件"><a href="#安装到文件下设置配置文件" class="headerlink" title="安装到文件下设置配置文件"></a>安装到文件下设置配置文件</h3><p>命令配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  //清除缓存</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo generate   //生成静态文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">hexo server</span></pre></td></tr></table></figure><h3 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h3><p>hexo g<br>hexo d</p><h3 id="域名更改"><a href="#域名更改" class="headerlink" title="域名更改"></a>域名更改</h3><p>腾讯云注册<br>首先设置CANDM文件 设置里面自己域名 ermao7.club<br>然后继续写如设置模式导向到自己仓库名字<br>@ 和 A 都可以写github的IP地址<br>如果俩个仓库 可以设置国外导向一个 国内导向一个</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://smelond.com/2018/06/21/hexo%E4%BB%8Ewindows%E6%90%AC%E5%AE%B6%E5%88%B0deepin/" target="_blank" rel="noopener">https://smelond.com/2018/06/21/hexo%E4%BB%8Ewindows%E6%90%AC%E5%AE%B6%E5%88%B0deepin/</a><br><a href="https://www.zhihu.com/question/31377141/answer/103056861" target="_blank" rel="noopener">https://www.zhihu.com/question/31377141/answer/103056861</a><br><a href="http://rosesnow.top/2018/12/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%971/" target="_blank" rel="noopener">http://rosesnow.top/2018/12/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%971/</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>deepin</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架(二)</title>
    <url>/Djang/20191205-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>创建 Django 应用的典型流程是，先建立数据模型，然后搭建管理站点，之后你的员工（或者客户）就可以向网站里填充数据了.</p><a id="more"></a><h3 id="URLs类"><a href="#URLs类" class="headerlink" title="URLs类"></a>URLs类</h3><p>URL 路径映射到了 Python 回调函数（“视图”）。路径字符串使用参数标签从URL中“捕获”相应值。当用户请求页面时，Django 依次遍历路径，直至初次匹配到了请求的 URL。(如果无匹配项，Django 会调用 404 视图。) 这个过程非常快，因为路径在加载时就编译成了正则表达式。</p><h3 id="View类"><a href="#View类" class="headerlink" title="View类"></a>View类</h3><p>视图函数的执行结果只可能有两种：返回一个包含请求页面元素的 HttpResponse 对象，或者是抛出 Http404 这类异常。至于执行过程中的其它的动作则由你决定。<br>通常来说，一个视图的工作就是：从参数获取数据，装载一个模板，然后将根据获取的数据对模板进行渲染。下面是一个 year_archive 的视图样例</p><h3 id="数据目标类变量"><a href="#数据目标类变量" class="headerlink" title="数据目标类变量"></a>数据目标类变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% block title %&#125;Articles for &#123;&#123; year &#125;&#125;&#123;% endblock %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;h1&gt;Articles for &#123;&#123; year &#125;&#125;&lt;&#x2F;h1&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% for article in article_list %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;p&gt;&#123;&#123; article.headline &#125;&#125;&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;p&gt;By &#123;&#123; article.reporter.full_name &#125;&#125;&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;p&gt;Published &#123;&#123; article.pub_date|date:&quot;F j, Y&quot; &#125;&#125;&lt;&#x2F;p&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% endfor %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% endblock %&#125;</span></pre></td></tr></table></figure><h3 id="每个文件的作用"><a href="#每个文件的作用" class="headerlink" title="每个文件的作用"></a>每个文件的作用</h3><p>manage.py: 一个让你用各种方式管理 Django 项目的命令行工具。你可以阅读 django-admin and manage.py 获取所有 manage.py 的细节。<br>里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls).<br>mysite/<strong>init</strong>.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。如果你是 Python 初学者，阅读官方文档中的 更多关于包的知识。<br>mysite/settings.py：Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看 Django 配置 了解细节。<br>mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。阅读 URL调度器 文档来获取更多关于 URL 的内容。<br>mysite/asgi.py: An entry-point for ASGI-compatible web servers to serve your project. See How to deploy with ASGI for more details.<br>mysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。阅读 如何使用 WSGI 进行部署 了解更多细节。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Djang</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web开发</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象(二)</title>
    <url>/python/20191205-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>具有抽象方法的类就是抽象类。<br>abc abstract class 抽象类的缩写 使用抽象类必须使用abc抽象模块<br><a id="more"></a></p><h3 id="绑定类的方法，静态方法-类方法"><a href="#绑定类的方法，静态方法-类方法" class="headerlink" title="绑定类的方法，静态方法,类方法"></a>绑定类的方法，静态方法,类方法</h3><p>@staticmethod #可以省略不写<br>@classmethod #必须写<br>调用非绑定类的方法(对象/实例方法)<br>tw = Person()<br>tw.say()<br>绑定类的方法，静态方法<br>Person.walk()<br>调用类方法<br>Person.drink()</p><p>总结:调用非绑定类是先实例化在调用,绑定类静态方法是直接调用 调用类方法也一样</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接口 抽象类关键字 !! </span></pre></td></tr><tr><td class="code"><pre><span class="line">定义一个抽象的实例方法&#x2F;非绑定类的方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">@abc.abstractmethod</span></pre></td></tr><tr><td class="code"><pre><span class="line">定义一个抽象的类方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">@abc.abstractclassmethod</span></pre></td></tr><tr><td class="code"><pre><span class="line">定义一个抽象的静态方法&#x2F;绑定类的方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">@abc.abstractstaticmethod</span></pre></td></tr></table></figure><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>魔术方法就是一个类/对象中的方法，和普通方法唯一的不同时，普通方法需要调用！而魔术方法是在特定时刻自动触发。<br>1.<strong>init</strong> 初始化调用<br>2.<strong>new</strong> 实例化调用<br>3.<strong>del</strong> 删除时候调用<br>3.<strong>call</strong> 调用时候用</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>python中的描述符是用于描述对象中的属性。主要作用就是对属性操作提供限制，验证，管理等相关权限的操作。</p><p>get 获取属性的操作<br>set 设置属性的操作<br>delete 删除属性的操作<br>描述符相当于Java中的封装 get set 操作 来对变量进行封装</p><h4 id="类内置属性"><a href="#类内置属性" class="headerlink" title="类内置属性"></a>类内置属性</h4><p><strong>dict</strong><br>获取当前类/对象成员组成的字典<br><strong>doc</strong><br>获取当前类/对象的文档，和函数一样使用’’’ 定义即可<br><strong>name</strong><br>类.<strong>name</strong>是获取当前类名,如果直接写<strong>name</strong>则是获取模块的名称<br><strong>bases</strong><br>获取类的继承列表中所有父类组成的元组</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象</title>
    <url>/python/20191204-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>面向对象特点<br>内聚指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。<br>耦合指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。</p><a id="more"></a><h3 id="类的描述"><a href="#类的描述" class="headerlink" title="类的描述"></a>类的描述</h3><p>类 抽象的：由类制作出对象叫做实例化<br>类只有俩种 成员属性成员方法<br>检测类成员<br>slef 自己 相当于Java this</p><h3 id="面向对象都具有三大特性：封装，继承-和-多态"><a href="#面向对象都具有三大特性：封装，继承-和-多态" class="headerlink" title="面向对象都具有三大特性：封装，继承 和 多态"></a>面向对象都具有三大特性：封装，继承 和 多态</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>private<br>加函数名前<em>_<br>私有化封装：在成员名称前添加2个_即可<br>protected 原则类外不可以 没有实现<br>函数名前</em><br>public 都可以</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承</p><h5 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h5><p>继承就是可以获取另外一个类中的成员属性和成员方法。(并非所有成员)<br>作用：继承的作用是增加代码的复用性，节省不必要的重复代码，提高开发效率，同时可以设置类之间的关系。<br>class 子类(父类)：#继承操作的关键步骤<br>pass<br>万物皆对象 object<br>super<br>在单继承的情况下，super()永远调用的是父类/父对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">super()和父类没有任何实质性的关系，只是有时候能调用到父类而已</span></pre></td></tr><tr><td class="code"><pre><span class="line">super().方法()      #python3的格式</span></pre></td></tr></table></figure><p><a href="适合类">父类名.方法()</a> 或者 <a href="适合对象">super().方法()</a><br>3.子类继承父类并不会将父类的所有成员复制到子类当中去，访问父类成员是间接通过父类来访问的，<br>5.子类可以重载父类中的方法，只需要设置和父类指定成员相同的名称即可实现重载，重载之后的成员，子类只会访问当前类中的成员，而不会调用父类中同名的成员</p><h5 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h5><p>python 可以多继承 但一般不用<br>多个父类具有相同的成员时，子类继承[继承列表]中第一个类的方法<br>Python 所以python使用 super() 类来解决了多继承的菱形继承问题<br>1.子类永远在父类的前面<br>2.如果继承了多个父类，那么按照()中的顺序在列表中摆放<br>多继承调用时相当递归<br>super()当出现多继承时，调用的顺序是根据类实例化时的执行顺序决定。<br>mixin 设计模式<br>相当于设置多个对象根据没个类属性不同来分别调用 Java中封装类 只调用所需要的</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>子类中如果重载父类的方法，并且还想将重载的父类方法借调过来使用，可以在重载的方法中使用如下方法</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，多种状态！就是一个类，根据不同的情况，相同的方法产生不同的结果。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架 (一)</title>
    <url>/Djang/20191204-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>Django是Python下web开发框架</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在deepin上安装命令 apt-install Django<br>选择在Pycham上开发在新建Django文件新建文件将选择第二个创建,最后一个admin勾打上<br>新建完成出现一系列文件表示成功</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><ol><li>出现数据库BUG选择将注释那个 if判断 因为是Python3 2 导向失败<br>因为Linux上 Python默认Python2 所以选择命令是Python3</li><li>ps aux | grep -i manage<br>命令可以清楚端口号占用 kill -9</li></ol><h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'default'</span>: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'NAME'</span>: <span class="string">"myserver"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"USER"</span>: <span class="string">"zl"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"PASSWORD"</span>:<span class="string">"123456"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"HOST"</span>:<span class="string">"127.0.0.1"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"port"</span>:<span class="string">"3306"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span><span class="comment">#编码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">STATIC_URL = <span class="string">'/static/'</span><span class="comment">#配置默认静态文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">如过css找不到</span></pre></td></tr><tr><td class="code"><pre><span class="line">STATICFILES_DIRS = (os.path.join(BASE_DIR,<span class="string">"static"</span>),)<span class="comment">#获得地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">``` </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#### 数据库迁移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">数据库迁移在用户模型类建立之后</span></pre></td></tr><tr><td class="code"><pre><span class="line">``` Python</span></pre></td></tr><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations</span></pre></td></tr><tr><td class="code"><pre><span class="line">python3 manage.py migrate</span></pre></td></tr><tr><td class="code"><pre><span class="line">``` </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">### 后台</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">``` Python</span></pre></td></tr><tr><td class="code"><pre><span class="line">python3 manage.py createsuperuser 建立admin用户</span></pre></td></tr></table></figure><p>后台会多出一个admin文件</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="用户模型类"><a href="#用户模型类" class="headerlink" title="用户模型类"></a>用户模型类</h4><p>构建用户模型 继承models.Model<br>用于后台界面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        verbose_name = <span class="string">"轮播图"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        verbose_name_plural = verbose_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">处理汉字</span></pre></td></tr></table></figure><h4 id="view视图类"><a href="#view视图类" class="headerlink" title="view视图类"></a>view视图类</h4><p>用于处理前段html</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aticle</span><span class="params">(request)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"request,"</span>index.html<span class="string">",content"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">index.html 前端页面 content 传入数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">用于返回前端数据</span></pre></td></tr></table></figure><h4 id="前端html类"><a href="#前端html类" class="headerlink" title="前端html类"></a>前端html类</h4><p>用于接收数据显示</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;% extends <span class="string">"base.html"</span> %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">表继承 单标签 用于前端继承</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;%block content%&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;%endblock%&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">表示接收数据 从后端接收数据 相当于 PHP 中的&lt;?php  ?&gt;</span></pre></td></tr></table></figure><p>语句</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;%%&#125; 变量&#123;&#123;&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> key,value <span class="keyword">in</span> img.items %&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;&#123; value &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;% endfor %&#125;</span></pre></td></tr></table></figure><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>CharField 字符串类型<br>BooleanField 布尔类型<br>models.DateTimeField 日期类型<br>models.TextField 大量文本<br>models.EmailField 邮箱类型<br>models.ImageField#图像<br>models.IntegerField#整形<br>models.FileField#文件</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Djang</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web开发</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式爬虫</title>
    <url>/%E7%88%AC%E8%99%AB/20191203-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>srapy框架</p><a id="more"></a><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>分布式爬虫 就是利于一个主机 redis<br>和多个从机来进行爬取<br>首先 从机开启任务模式 python run.py china<br>主机在根据redis 创建列表键的方法<br>从机进行爬取 ,redis 有去重的功能</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>项目的主配置信息 scrapy.cfg 用来分布式处理服务器<br>scrapy 文件夹 写规则 items.py 写数据处理模板、middlewares 中间件、pipelines 管道用来永久化持久化储存 setting 设置配置文件<br>scrapy<br>scrawl 运行</p><p>scrapy startproject yuehui<br>cd yuehui</p><p>scrapy genspider yuehui163 “<a href="http://yueh" target="_blank" rel="noopener">http://yueh</a><br>scrapy crawl yuehui163 -s JOBDIR=job_info/001<br>python run.py china</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>python 装饰器</title>
    <url>/python/20191203-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>装饰器就是对函数或者方法或者类进行修饰 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。 主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。<br><a id="more"></a></p><h3 id="装饰器特点"><a href="#装饰器特点" class="headerlink" title="装饰器特点"></a>装饰器特点</h3><p>Python函数与其他函数不同一点是 函数参数可以是函数<br>装饰器没有返回值</p><h3 id="装饰器使用"><a href="#装饰器使用" class="headerlink" title="装饰器使用"></a>装饰器使用</h3><p>装饰器就是定义一个函数来装饰所@的函数<br>将函数当成参数传入 并且在装饰器调用 加上所装饰的方法</p><h4 id="方法带惨装饰-方法返回值装饰"><a href="#方法带惨装饰-方法返回值装饰" class="headerlink" title="方法带惨装饰 方法返回值装饰"></a>方法带惨装饰 方法返回值装饰</h4><p>装饰器有外部函数和内部函数 所装饰函数有参数的时候 就在内部函数定义 <em>arg *</em>keay 外部函数参数只有一个<br>如果所装饰的函数有返回值 那么 在内部函数中 接收该返回值 并且return出去 外部函数 return内部函数</p><h4 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h4><p>在定义有参数的外部函数来接受 @装饰器函数 返回@description<br>返回值 是接收函数的那个参数 相当于设置一个关卡 用if判断 返回值仍然是 接收函数的</p><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>def <strong>call</strong>(self, func):<br># 将基本函数存入对象<br>self.func = func</p><pre><code># 返回inner函数
return self.inner</code></pre><h3 id="然后在定义装饰器函数"><a href="#然后在定义装饰器函数" class="headerlink" title="然后在定义装饰器函数"></a>然后在定义装饰器函数</h3><p>self.func()<br>装饰类 同理 将类传入 进行实例化<br>多个装饰器 从下到上</p><p>装饰器 多重函数嵌套<br>返回值都是函数为参数的<br>三个函数 是装饰器判断使用哪个方法装饰 俩个函数<br>三个类 俩个类</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/deepin/20191203-index.html</url>
    <content><![CDATA[<!-- build time:Fri Jan 03 2020 16:55:17 GMT+0800 (CST) --><p>git配置<br><a id="more"></a></p><p>git config –global user.name “”<br>git config –global user.email””<br>git config –list 查看<br>建立一个文件夹<br>git init 初始化在当前文件夹<br>git remote add origin 仓库链接 打开<br>git clone 厂库链接 克隆<br>git add 添加当前本地<br>git status 查看有无更更改<br>git commit -m “修改元素” 提交更改<br>git push origin master 上传git</p><p>所以，需要用git diff这个命令看看：</p><p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：</p><p>版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
